lz4_decode_block: ; de = source, hl = destination, bc = end

    ; exit if hl >= bc
    ld      a,h ; high byte
    cp      b
    jp      nz,.token

    ld      a,l ; low byte
    cp      c 
    ret     nc ; l > c


; Each sequence starts with a token.
.token:

    push    bc; store end of output

    ; literals length, lower 4 bit
    ld      a,[de]
    inc     de
    ld      [coreLZ4token],a
    swap    a
    and     $f

    ; no literals to copy
    jp      z,.match 

    push    hl ; store output pointer

    ; set initial value for literals length (includes the current output offset)
    ld      b,0
    ld      c,a
    add     hl,bc

    ; if the literal length is less than 15 there are no additional length bytes
    cp      15
    jp      nz,.copy_literals


    ; get literals length ; while [de] === 255
.literal_length_loop:
    ld      a,[de] ; next literal
    ld      c,a
    add     hl,bc
    inc     de
    cp      255
    jp      z,.literal_length_loop


.copy_literals: 

    ; load literals length into bc and restore output pointer
    ld      b,h
    ld      c,l
    pop     hl 

    ; while hl < bc do [hl++] = [de++]
.literals_copy_loop:

    ; hl >= bc 
    ld      a,h ; high byte 
    cp      b
    jp      nz,.literals_copy_next

    ld      a,l ; low byte 
    cp      c
    jp      z,.match ; l == c

.literals_copy_next:

    ; wait for vblank
    ld      a,[rSTAT]       ; <---+
    and     STATF_BUSY      ;     |
    jr      nz,@-4          ; ----+

    ld      a,[de]
    inc     de
    ld      [hli],a
    jp      .literals_copy_loop


.match:

    push    hl

    ; 2 byte match offset (little endian)
    ld      a,[de]
    ld      [coreLZ4matchOffset+1],a
    inc     de
    ld      a,[de]
    ld      [coreLZ4matchOffset],a
    inc     de

    ; restore token
    ld      a,[coreLZ4token]
    and     $f ; get match length (4 + [a] bytes)

    ; store initial match length into hl
    add     4
    ld      b,0
    ld      c,a
    add     hl,bc

    ; if the match length is less than 15 there are no additional length bytes
    cp      19
    jp      nz,.copy_match


    ; get match length
.match_length_loop:
    ld      a,[de] ; next match length
    ld      c,a
    add     hl,bc
    inc     de
    cp      255
    jp      z,.match_length_loop


.copy_match:

    ; load match length into bc and restore output pointer
    ld      b,h
    ld      c,l
    pop     hl 
    
    ; store current input position and setup up copy offset
    push    de

    ; de -= coreLZ4matchOffset 
    ld      a,[coreLZ4matchOffset]
    ld      d,a
    ld      a,[coreLZ4matchOffset+1]
    ld      e,a

    ; subtract low byte
    ld      a,l
    and     a ; clear carry
    sbc     e
    ld      e,a

    ; subtract high byte
    ld      a,h
    sbc     d
    ld      d,a

    ; while hl < bc do [hl++] = [de++]
.copy_match_loop:
    
    ; hl >= bc 
    ld      a,h ; high byte 
    cp      b
    jp      nz,.copy_match_next

    ld      a,l ; low byte 
    cp      c
    jp      z,.match_done ; l == c

.copy_match_next:
    ; wait for vblank
    ld      a,[rSTAT]       ; <---+
    and     STATF_BUSY      ;     |
    jr      nz,@-4          ; ----+

    ld      a,[de]
    inc     de
    ld      [hli],a
    jp      .copy_match_loop

.match_done:
    pop     de; restore current input position
    pop     bc; restore end of output
    jp      lz4_decode_block

