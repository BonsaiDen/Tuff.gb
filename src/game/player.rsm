; Player ----------------------------------------------------------------------
player_init:

    ; Position 
    ld      a,20
    ld      [playerX],a
    ld      a,32
    ld      [playerY],a

    ; Direction
    ld      a,PLAYER_DIRECTION_RIGHT
    ld      [playerDirection],a
    ld      a,255
    ld      [playerDirectionLast],a

    ; Animation
    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    ld      a,255
    ld      [playerAnimationLast],a

    ; Jumping / Falling
    call    player_reset

    ; Sprite
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_enable

    ret


player_reset:

    ; Gravity
    ld      a,1
    ld      [playerGravityTick],a

    ld      a,0
    ld      [playerJumpForce],a
    ld      [playerJumpPressed],a
    ld      [playerFallSpeed],a

    ld      a,1
    ld      [playerOnGround],a

    ; Movement
    ld      a,0
    ld      [playerSpeedRight],a
    ld      [playerSpeedLeft],a
    ld      [playerDecTick],a
    ld      [playerMoveTick],a

    ; Other
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a

    ld      a,255
    ld      [playerDissolveTick],a

    ret



; Player Logic ----------------------------------------------------------------
player_update:

    ; check if we're dissolving
    ld      a,[playerDissolveTick]
    cp      255
    jp      z,.control

    ; wait for 25 ticks before flashing screen and resetting player position
    ;call    player_gravity
    ;ld      a,[playerY]
    ;ld      [playerYOffset],a

    ld      a,[playerDissolveTick]
    inc     a
    ld      [playerDissolveTick],a
    cp      30
    jp      nz,.update

    ld      a,255
    ld      [playerDissolveTick],a

    call    game_flash_screen
    call    save_reset_player
    ret


    ; control / animation
.control:
    call    player_accelerate
    call    player_decelerate
    call    player_move

    ; check for hazard
    ld      a,[mapCollisionFlag]
    cp      4
    jp      z,player_dissolve

    call    player_gravity

    ; check for hazard
    ld      a,[mapCollisionFlag]
    cp      4
    jp      z,player_dissolve

    call    player_sleep

    ; y position for sprite
    ld      a,[playerY]
    ld      [playerYOffset],a


    ; check for water
    ld      a,[playerY]
    sub     6
    ld      c,a
    ld      a,[playerX]
    ld      b,a
    call    map_get_collision


    ; check if the pixel still lies in water
    ld      a,[mapCollisionFlag]
    cp      2 
    jp      z,.water
    cp      3
    jp      z,.water
    cp      4
    jp      z,player_dissolve

    ; reset water variables when on land
.land:
    ld      a,0
    ld      [playerInWater],a
    ld      [playerWaterHitDone],a
    jp      .update

.water:
    call    player_water_update

    ; animation / other logic
.update:
    call    player_animate
    call    player_scroll_map

    ; update player sprite position
    ld      a,[playerX]
    ld      b,a
    ld      a,[playerYOffset]
    ld      c,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_position

    ret     


player_dissolve:

    ; jump out if already dissolving
    ld      a,[playerDissolveTick]
    cp      255
    jp      nz,.done

    ; dissolve player when hitting a hazard
    ld      a,PLAYER_ANIMATION_DISSOLVE
    ld      [playerAnimation],a
    ld      a,0
    ld      [playerDissolveTick],a
    ld      [mapCollisionFlag],a

.done:
    ret


player_timer_125:
    call    player_sleep_timer
    call    player_water_timer
    ret


; Player Water Movement -------------------------------------------------------
playerWaterSwimOffsetTable:
    DB      1,1,2,2,1,1,0,0,1,1,2,2,1,1,0,0

playerWaterHitOffsetTable:
    DB      1,2,3,4,6,7,8,9,10,8,7,7,6,6,6,5,5,5,5,4
    DB      4,4,4,3,3,3,3,3,2,2,2,2,2,1,1,1


player_water_update:

    ; check for the intitial frame on whic we hit the water
    ld      a,[playerInWater]
    cp      0
    jp      nz,.not_initial;

    ; save speed
    ld      a,[playerFallFrames]
    ld      [playerWaterHitDepth],a

    ld      a,1
    ld      [playerInWater],a

    ld      a,0
    ld      [playerFallFrames],a

.not_initial:


    ; prevent sleep and reset fall speed
    ld      a,0
    ld      [playerSleepTick],a
    ld      [playerFallSpeed],a

    ; check swimming offset or initial hit offset
    ld      a,[playerWaterHitDone]
    cp      1
    jp      z,.animate_water
    
    ; initial "splash / hit" offset
    ld      a,[playerWaterTick]
    cp      35; check if we're done
    jp      z,.water_hit_done

    ld      a,[playerWaterTick]
    inc     a
    ld      [playerWaterTick],a

    ; load the y offset for the splash
    ld      hl,playerWaterHitOffsetTable
    ld      b,0
    ld      c,a
    add     hl,bc

    ; set diving / surfacing animation
    cp      14
    jp      c,.down
    ld      a,PLAYER_ANIMATION_SURFACE
    jp      .animate
.down:
    ld      a,PLAYER_ANIMATION_FALL

.animate:
    ld      [playerAnimation],a

    ; load y offset value
    ld      a,[hl]
    ld      b,a

    ; adjust the depth based on the fall speed
    ld      a,[playerWaterHitDepth]
    cp      15
    jp      nc,.fast
    srl     b; divice depth by 2 if speed was low

    ; apply
.fast:
    ld      a,[playerY] 
    add     b
    ld      [playerYOffset],a
    ret


.water_hit_done:
    ld      a,1
    ld      [playerWaterHitDone],a
    ld      a,7; set the value so the first movement after the splash is up
    ld      [playerWaterTick],a
    ret 


    ; swimming offset
.animate_water:
    ld      a,[playerWaterTick]

    ld      hl,playerWaterSwimOffsetTable
    ld      b,0
    ld      c,a
    add     hl,bc
    ld      a,[hl]
    ld      b,a

    ld      a,[playerWaterTick]
    cp      8
    jp      c,.move_down ; if 4 is greater than the tick, move the player down (0, 1, 2, 3)

.move_up: ; move the player up, 4, 5, 6, 7
    ld      a,[playerY] 
    sub     b
    ld      [playerYOffset],a
    ret

.move_down:
    ld      a,[playerY]
    add     b
    ld      [playerYOffset],a
    ret


player_water_timer:

    ; check if in water
    ld      a,[playerInWater]
    cp      0
    jp      z,.done

    ; check if we've finished the initial splash offseting
    ld      a,[playerWaterHitDone]
    cp      0
    ret     z

    ; update offset tick 
.tick:
    ld      a,[playerWaterTick]
    inc     a
    cp      16
    jp      nz,.done
    ld      a,0

.done:
    ld      [playerWaterTick],a
    ret



; Player Collisions -----------------------------------------------------------

; if a collision is detected these will unset the zero flag  (nz = col, z = nocol)
; call     player_collision_up
; jp       nz, .collided 
player_collision_up: 

    ; middle
    ld      a,[playerY]
    sub     PLAYER_HEIGHT
    ld      c,a

    ld      a,[playerX]
    ld      b,a
    call    map_get_collision
    ret     nz

    ; right half 
    ld      a,[playerY]
    sub     PLAYER_HEIGHT
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 3
    ld      b,a
    call    map_get_collision
    ret     nz

    ; left half 
    ld      a,[playerY]
    sub     PLAYER_HEIGHT
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret


player_collision_down: 

    ; middle
    ld      a,[playerY]
    ld      c,a

    ld      a,[playerX]
    ld      b,a
    call    map_get_collision
    ret     nz

    ; right half 
    ld      a,[playerY]
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 3
    ld      b,a
    call    map_get_collision
    ret     nz

    ; left half 
    ld      a,[playerY]
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret     


player_collision_left:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     nz

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     nz

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     


player_collision_right:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    ret     nz

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    ret     nz

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret


; Handle Map Scrolling --------------------------------------------------------
player_scroll_map:

    ; left ------------------------------
    ld      a,[playerX]
    cp      2 ; < 1
    jp      nc,.check_right
    call    map_scroll_left

    ld      a,159
    ld      [playerX],a
    jp      .done


    ; right -----------------------------
.check_right:
    ld      a,[playerX]
    cp      159 ; > 159
    jp      c,.check_up
    call    map_scroll_right

    ld      a,2
    ld      [playerX],a
    jp      .done


    ; up --------------------------------
.check_up:
    ld      a,[playerY]
    cp      1 ; < 1
    jp      nc,.check_down
    call    map_scroll_up

    ; add a boost to the jump to we can reach a platform or something
    ld      a,PLAYER_JUMP_SCREEN_BOOST
    ld      [playerJumpForce],a

    ld      a,126
    ld      [playerY],a
    jp      .done


    ; down ------------------------------
.check_down:
    ld      a,[playerY]
    cp      127 ; 
    jp      c,.done
    call    map_scroll_down

    ld      a,1
    ld      [playerY],a

.done:
    ret


; Gravity ---------------------------------------------------------------------
player_gravity:

    ; only increase / decrease gravity every PLAYER_GRAVITY_INTERVAL ticks
    ld      a,[playerGravityTick]
    dec     a
    ld      [playerGravityTick],a

    ; check if the ticker reached 0
    cp      0
    jp      nz,.no_tick

    ; update gravity
    call    player_decrease_jump
    call    player_increase_fall

    ; reset ticker
    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

.no_tick:

    call   player_fall
    call   player_jump

    ; if jump force > 0 set jump animation
    ld     a,[playerJumpForce]
    cp     0
    jp     z,.no_jump

    ; set jump animation
    ld      a,PLAYER_ANIMATION_JUMP
    ld      [playerAnimation],a
    jp     .done

.no_jump:

    ; if fall speed > 0 set fall animation
    ld     a,[playerFallSpeed]
    cp     0
    jp     z,.done

    ; set fall animation
    ld      a,PLAYER_ANIMATION_FALL
    ld      [playerAnimation],a

.done:
    ret


player_jump:

    ; see if the jump button has been pressed
    ld      a,[inputState]
    and     %00000001
    jp      z,.not_pressed

    ; check if the player is continuosly pressing the button
    ld      a,[playerJumpPressed]
    cp      1
    jp      z,.still_pressed

    ; otherwrise set the button pressed on first press
    ld      a,1
    ld      [playerJumpPressed],a

    ; check if we're in water (and the splash offset is done)
    ld      a,[playerWaterHitDone]
    cp      1
    jp      z,.jump_water

    ; and check if we're on the ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.no_ground

    ; land jump force
    ld      a,PLAYER_JUMP_LAND
    jp      .jump

    ; water jump force
.jump_water:
    ld      a,PLAYER_JUMP_WATER

    ; if we are, set the initial jump force and reset the gravity ticker
.jump:
    ld      [playerJumpForce],a

    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a
    jp      .still_pressed


    ; reset the jump state
.not_pressed:
    ld      a,0
    ld      [playerJumpPressed],a


    ; if we're still pressing the button or are in the air update the jump value
.still_pressed:
.no_ground:

    ; check if we need to move upwards
    ld      a,[playerJumpForce]
    ld      d,a
    cp      0
    jp      z,.done

    ; check if we're the button was released
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.apply_force

    ; if so quickly reduce the jump force
    jp      .done

    ; move player upwards
.apply_force:
    
    ; reset on ground flag
    ld      a,0
    ld      [playerOnGround],a

    ; move player upwards
    ld      a,[playerY]
    
    ; check collision at current top pixel
    call    player_collision_up
    jp      nz,.collision

    ld      a,[playerY]
    dec     a

    ; check again with new top pixel
    call    player_collision_up
    jp      nz,.collision

    ; finally set new top pixel
    ld      a,[playerY]
    dec     a
    ld      [playerY],a

    ; loop until stored jump force reaches 0
    dec     d
    jp      nz,.apply_force
    jp      .done

.collision:

    ld      a,0
    ld      [playerJumpPressed],a

    ld      a,[playerJumpForce]
    srl     a
    srl     a
    ld      [playerJumpForce],a

.done:
    ret


player_decrease_jump:

    ; check whether the jump button is still pressed;
    ; if not we decrease the jump force more quickly
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.fast

    ; normal decrease -1
    ld      a,[playerJumpForce]
    cp      0
    jp      z,.done

    dec     a
    ld      [playerJumpForce],a

    ; fast decrease /= 2
.fast:
    ld      a,[playerJumpForce]
    srl     a
    ld      [playerJumpForce],a

.done:
    ret


player_fall:

    ld      a,[playerFallSpeed]
    ld      d,a ; load the current fall speed as the loop counter
    cp      0
    ret     z

.fall:

    call    player_collision_down
    jp      nz,.collision

    ; reset ground state
    ld      a,0
    ld      [playerOnGround],a
    
    ; increase player position
    ld      a,[playerY]
    inc     a
    ld      [playerY],a
        
    ; loop until stored fall speed reaches 0
    dec     d
    jp      nz,.fall
    jp      .no_collision

.collision:
    ld      a,0
    ld      [playerFallSpeed],a
    ld      [playerFallFrames],a
    ld      a,1
    ld      [playerOnGround],a
    ret

.no_collision:
    ; increase the number of frames we were falling
    ld      a,[playerFallFrames]
    cp      $ff
    ret     z
    inc     a
    ld      [playerFallFrames],a
    ret


player_increase_fall:

    ; if we're still jumping do not increase the fall speed
    ld      a,[playerJumpForce]
    cp      0
    jp      nz,.no_increase

    ; if we're in water do not increase the fall speed
    ld      a,[playerInWater]
    cp      0
    jp      nz,.no_increase

    ; otherwise increase it untiul we reach the maximum
    ld      a,[playerFallSpeed]
    cp      PLAYER_GRAVITY_MAX
    jp      z,.no_increase

    inc     a
    ld      [playerFallSpeed],a

.no_increase:
    ret



; Movement --------------------------------------------------------------------
player_accelerate:

    ; check which direction is pressed
    ld      a,[inputState]
    and     %00100000
    jp      nz,.left

    ld      a,[inputState]
    and     %00010000
    jp      nz,.right

    ; not moving
    jp      .done

.right:
    ld      hl,playerSpeedRight
    ld      b,PLAYER_DIRECTION_RIGHT
    jp      .accelerate

.left:
    ld      hl,playerSpeedLeft
    ld      b,PLAYER_DIRECTION_LEFT

.accelerate:

    ; set player direction
    ld      a,b
    ld      [playerDirection],a

    ; load speed variable
    ld      a,[hl]

    ; check if max speed
    cp      PLAYER_SPEED_MAX
    jp      z,.done

    ; if not increase
    inc     a
    ld      [hl],a

.done:
    ret


player_decelerate:

    ; only decelerate on every 10th frame
    ld      a,[playerDecTick]
    inc     a
    cp      10
    jp      nz,.no_tick

.decrease_right:

    ; check if right direction is still pressed
    ld      a,[inputState]
    and     %00010000
    jp      nz,.decrease_left

    ; right
    ld      a,[playerSpeedRight]
    cp      0
    jp      z,.decrease_left
    dec     a
    ld      [playerSpeedRight],a

.decrease_left:

    ; check if left direction is still pressed
    ld      a,[inputState]
    and     %00100000
    jp      nz,.done

    ; left
    ld      a,[playerSpeedLeft]
    cp      0
    jp      z,.done
    dec     a
    ld      [playerSpeedLeft],a

.done:
    ld      a,0

.no_tick:
    ld      [playerDecTick],a
    ret


; Movement Logic --------------------------------------------------------------
player_move:

    ; are we moving at all?
    ld     a,[playerSpeedLeft]
    ld     b,a
    ld     a,[playerSpeedRight]
    add    a,b
    cp     0
    jp     z,.stopped

    ; set walking animation when on ground
    ld     a,[playerOnGround]
    cp     1
    jp     nz,.not_on_ground

    ld     a,PLAYER_ANIMATION_WALKING
    ld     [playerAnimation],a
    
.not_on_ground:

    ld     a,[playerInWater]
    cp     0
    jp     z,.not_in_water

    ld     a,PLAYER_ANIMATION_SWIMMING
    ld     [playerAnimation],a

    ; half speed when in water
    ld     a,[playerMoveTick]
    cp     1
    jp     nz,.delay
    ld     a,0
    ld     [playerMoveTick],a

.not_in_water:

    ; load x position
    ld     a,[playerX]
    ld     d,a

    ; move right -----------------------------------
.move_right:
    ld     a,[playerSpeedRight]
    cp     0
    jp     z,.move_left
    ld     e,a

.loop_right:

    call   player_collision_right
    jp     z,.not_blocked_right

    ; set pushing animation when not in water
    ld     a,[playerInWater]
    cp     0
    jp     z,.pushing_right
    jp     .idle_right

.pushing_right:
    ld     a,PLAYER_ANIMATION_PUSHING
    ld     [playerAnimation],a
    jp     .move_left

.idle_right:
    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    jp     .move_left

.not_blocked_right:
    inc    d
    ld     a,d
    ld     [playerX],a
    dec    e
    jp     nz,.loop_right


    ; move left ------------------------------------
.move_left:
    ld     a,[playerSpeedLeft]
    cp     0
    jp     z,.moved
    ld     e,a

.loop_left:

    call   player_collision_left
    jp     z,.not_blocked_left

    ; set pushing animation when not in water
    ld     a,[playerInWater]
    cp     0
    jp     z,.pushing_left
    jp      .idle_left

.pushing_left:
    ld     a,PLAYER_ANIMATION_PUSHING
    ld     [playerAnimation],a
    jp     .moved

.idle_left:
    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    jp     .moved

.not_blocked_left:
    dec    d
    ld     a,d
    ld     [playerX],a
    dec    e
    jp     nz,.loop_left


    ; moved ----------------------------------------
.moved:
    ld     a,d
    ld     [playerX],a
    ret    z

.stopped: 

    ; reset to idle animation if on ground
    ld     a,[playerOnGround]
    cp     0
    jp     z,.stopped_water

    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    ret

.stopped_water:
    ld     a,[playerInWater]
    cp     0
    ret    z

    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    ret

.delay:
    inc    a
    ld     [playerMoveTick],a
    ret



; Animation Updates -----------------------------------------------------------
player_animate:

    ; check for animation changes
    ld      a,[playerAnimationLast]
    ld      b,a
    ld      a,[playerAnimation]
    cp      b
    jp      z,.no_animation_change
    
    ; switch to new animation
    ld      b,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_set
    call    sprite_animation_start
    ld      a,b
    ld      [playerAnimationLast],a

.no_animation_change:

    ; check for direction changes
    ld      a,[playerDirectionLast]
    ld      b,a
    ld      a,[playerDirection]
    cp      b
    jp      z,.no_direction_change

    ; switch to new direction
    cp      PLAYER_DIRECTION_RIGHT
    jp      z,.direction_right

.direction_left:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_unset_mirror
    jp      .direction_changed

.direction_right:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_mirror
    jp      .direction_changed

.direction_changed:

    ; reset animation frame
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_start

    ld      a,[playerDirection]
    ld      [playerDirectionLast],a

.no_direction_change:
    ret


; Sleep Timer -----------------------------------------------------------------
player_sleep:

    ; in case no button is pressed decrease the sleep ticker 
    ld      a,[inputState]
    and     %00110001
    jp      nz,.active

    ; also check whether we're on the ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.active

    ; check sleep ticker
    ld      a,[playerSleepTick]
    cp      0
    ret     nz

    ; set sleeping
    ld      a,PLAYER_ANIMATION_SLEEP
    ld      [playerAnimation],a
    jp      .done

.active:
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a
    jp      .done

.done:
    ret

player_sleep_timer:
    ld      a,[playerSleepTick]
    cp      0
    ret     z
    dec     a
    ld      [playerSleepTick],a
    ret

