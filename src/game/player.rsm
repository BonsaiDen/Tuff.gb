SECTION "PlayerLogic",ROM0

; Player ----------------------------------------------------------------------
player_init:

    ; Position 
    ld      a,8
    ld      [playerX],a
    ld      a,16
    ld      [playerY],a

    ; Direction
    ld      a,PLAYER_DIRECTION_RIGHT
    ld      [playerDirection],a
    ld      a,0
    ld      [playerDirectionLast],a

    ; Animation
    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    ld      a,255
    ld      [playerAnimationLast],a

    ; Jumping / Falling
    call    player_reset

    ; Sprite
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_enable

    ret


player_reset:

    ; Gravity
    ld      a,1
    ld      [playerGravityTick],a

    ld      a,0
    ld      [playerJumpForce],a
    ld      [playerJumpPressed],a
    ld      [playerFallSpeed],a

    ld      a,1
    ld      [playerOnGround],a

    ; Movement
    ld      a,0
    ld      [playerSpeedRight],a
    ld      [playerSpeedLeft],a
    ld      [playerDecTick],a
    ld      [playerMoveTick],a

    ; Sliding
    ld      a,0
    ld      [playerDirectionWall],a
    ld      [playerWallSlideDir],a
    ld      [playerWallSlideTick],a
    ld      [playerWallJumpPressed],a

    ; Other
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a

    ld      a,255
    ld      [playerDissolveTick],a

    ret



; Player Logic ----------------------------------------------------------------
player_update:

    ; check if we're dissolving
    ld      a,[playerDissolveTick]
    cp      255
    jp      z,.control

    ; wait for 25 ticks before flashing screen and resetting player position
    ld      a,[playerY]
    add     2
    ld      [playerYOffset],a

    ld      a,[playerDissolveTick]
    inc     a
    ld      [playerDissolveTick],a
    cp      30
    jp      nz,.update

    ld      a,255
    ld      [playerDissolveTick],a

    call    game_flash_screen
    call    save_reset_player
    ret


    ; control / animation
.control:
    call    player_accelerate
    call    player_decelerate
    call    player_move

    ; check for hazard
    ld      a,[mapCollisionFlag]
    cp      4
    jr      z,player_dissolve

    ; Jumping / Falling
    call    player_gravity
    call    player_slide_wall

    ; check for hazard
    ld      a,[mapCollisionFlag]
    cp      4
    jr      z,player_dissolve

    call    player_scroll_map
    call    player_sleep


    ; y position for sprite
    ld      a,[playerY]
    ld      [playerYOffset],a


    ; check for water
    ld      a,[playerY]
    sub     6
    ld      c,a
    ld      a,[playerX]
    ld      b,a
    call    map_get_collision


    ; check if the pixel still lies in water
    ld      a,[mapCollisionFlag]
    cp      2 
    jr      z,.water
    cp      3
    jr      z,.water
    cp      4
    jr      z,player_dissolve

    ; reset water variables when on land
.land:
    ld      a,0
    ld      [playerInWater],a
    ld      [playerWaterHitDone],a
    jp      .update

.water:
    call    player_water_update

    ; animation / other logic
.update:
    call    player_animate

    ; update player sprite position
    ld      a,[playerX]
    ld      b,a
    ld      a,[playerYOffset]
    ld      c,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_position

    ret     


player_dissolve:

    ; jump out if already dissolving
    ld      a,[playerDissolveTick]
    cp      255
    jp      nz,.done

    ; dissolve player when hitting a hazard
    ld      a,PLAYER_ANIMATION_DISSOLVE
    ld      [playerAnimation],a
    ld      a,0
    ld      [playerDissolveTick],a
    ld      [mapCollisionFlag],a

.done:
    ret


player_timer_125:
    call    player_sleep_timer
    call    player_water_timer
    ret


; Player Water Movement -------------------------------------------------------
playerWaterSwimOffsetTable:
    DB      1,1,2,2,1,1,0,0,1,1,2,2,1,1,0,0

playerWaterHitOffsetTable:
    DB      1,2,3,4,6,7,8,9,10,8,7,7,6,6,6,5,5,5,5,4
    DB      4,4,4,3,3,3,3,3,2,2,2,2,2,1,1,1


player_water_update:

    ; check for the intitial frame on whic we hit the water
    ld      a,[playerInWater]
    cp      0
    jp      nz,.not_initial;

    ; save speed
    ld      a,[playerFallFrames]
    ld      [playerWaterHitDepth],a

    ld      a,1
    ld      [playerInWater],a

    ld      a,0
    ld      [playerFallFrames],a

.not_initial:

    ; prevent sleep and reset fall speed
    ld      a,0
    ld      [playerSleepTick],a
    ld      [playerFallSpeed],a

    ; check swimming offset or initial hit offset
    ld      a,[playerWaterHitDone]
    cp      1
    jp      z,.animate_water
    
    ; initial "splash / hit" offset
    ld      a,[playerWaterTick]
    cp      35; check if we're done
    jr      z,.water_hit_done

    ld      a,[playerWaterTick]
    inc     a
    ld      [playerWaterTick],a

    ; load the y offset for the splash
    ld      hl,playerWaterHitOffsetTable
    ld      b,0
    ld      c,a
    add     hl,bc

    ; set diving / surfacing animation
    cp      14
    jp      c,.down
    ld      a,PLAYER_ANIMATION_SURFACE
    jp      .animate
.down:
    ld      a,PLAYER_ANIMATION_FALL

.animate:
    ld      [playerAnimation],a

    ; load y offset value
    ld      a,[hl]
    ld      b,a

    ; adjust the depth based on the fall speed
    ld      a,[playerWaterHitDepth]
    cp      15
    jp      nc,.fast
    srl     b; divice depth by 2 if speed was low

    ; apply
.fast:
    ld      a,[playerY] 
    add     b
    ld      [playerYOffset],a
    ret


.water_hit_done:
    ld      a,1
    ld      [playerWaterHitDone],a
    ld      a,7; set the value so the first movement after the splash is up
    ld      [playerWaterTick],a
    ret 


    ; swimming offset
.animate_water:
    ld      a,[playerWaterTick]

    ld      hl,playerWaterSwimOffsetTable
    ld      b,0
    ld      c,a
    add     hl,bc
    ld      a,[hl]
    ld      b,a

    ld      a,[playerWaterTick]
    cp      8
    jp      c,.move_down ; if 4 is greater than the tick, move the player down (0, 1, 2, 3)

.move_up: ; move the player up, 4, 5, 6, 7
    ld      a,[playerY] 
    sub     b
    ld      [playerYOffset],a
    ret

.move_down:
    ld      a,[playerY]
    add     b
    ld      [playerYOffset],a
    ret


player_water_timer:

    ; check if in water
    ld      a,[playerInWater]
    cp      0
    jp      z,.done

    ; check if we've finished the initial splash offseting
    ld      a,[playerWaterHitDone]
    cp      0
    ret     z

    ; update offset tick 
.tick:
    ld      a,[playerWaterTick]
    inc     a
    cp      16
    jp      nz,.done
    ld      a,0

.done:
    ld      [playerWaterTick],a
    ret



; Player Collisions -----------------------------------------------------------

; if a collision is detected these will unset the zero flag  (nz = col, z = nocol)
; call     player_collision_up
; jp       nz, .collided 
player_collision_up: 

    ; middle
    ld      a,[playerY]
    sub     PLAYER_HEIGHT
    ld      c,a

    ld      a,[playerX]
    ld      b,a
    call    map_get_collision
    ret     nz

    ; right half 
    ld      a,[playerY]
    sub     PLAYER_HEIGHT
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 3
    ld      b,a
    call    map_get_collision
    ret     nz

    ; left half 
    ld      a,[playerY]
    sub     PLAYER_HEIGHT
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret


player_collision_down: 

    ; middle
    ld      a,[playerY]
    ld      c,a

    ld      a,[playerX]
    ld      b,a
    call    map_get_collision
    ret     nz

    ; right half 
    ld      a,[playerY]
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 3
    ld      b,a
    call    map_get_collision
    ret     nz

    ; left half 
    ld      a,[playerY]
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret     


player_collision_left:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     nz

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     nz

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     


player_collision_right:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    ret     nz

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    ret     nz

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret


; Wall Jump Collision Checks --------------------------------------------------
player_collision_left_all:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision
    
    ; set collision flag
    or      1 ; set nz
    ret

.no_collision:
    cp      a ; set z
    ret     


player_collision_right_all:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; set collision flag
    or      1 ; set nz
    ret

.no_collision:
    cp      a ; set z
    ret     


; Handle Map Scrolling --------------------------------------------------------
player_scroll_map:

    ; left ------------------------------
    ld      a,[playerX]
    cp      2 ; < 1
    jp      nc,.check_right
    call    map_scroll_left

    ld      a,157
    ld      [playerX],a
    jp      .done


    ; right -----------------------------
.check_right:
    ld      a,[playerX]
    cp      158 ; > 159
    jp      c,.check_up
    call    map_scroll_right

    ld      a,3
    ld      [playerX],a
    jp      .done


    ; up --------------------------------
.check_up:
    ld      a,[playerY]
    cp      2 ; < 1
    jp      nc,.check_down
    call    map_scroll_up

    ; add a boost to the jump to we can reach a platform or something
    ld      a,PLAYER_JUMP_SCREEN_BOOST
    ld      [playerJumpForce],a

    ld      a,125
    ld      [playerY],a
    jp      .done


    ; down ------------------------------
.check_down:
    ld      a,[playerY]
    cp      126 ; 
    jp      c,.done
    call    map_scroll_down

    ld      a,3
    ld      [playerY],a

.done:
    ret


; Gravity ---------------------------------------------------------------------
player_gravity:

    ; only increase / decrease gravity every PLAYER_GRAVITY_INTERVAL ticks
    ld      a,[playerGravityTick]
    dec     a
    ld      [playerGravityTick],a

    ; check if the ticker reached 0
    cp      0
    jp      nz,.no_tick

    ; update gravity
    call    player_decrease_jump
    call    player_increase_fall

    ; reset ticker
    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

.no_tick:

    call   player_fall
    call   player_jump

    ; if jump force > 0 set jump animation
    ld     a,[playerJumpForce]
    cp     0
    jp     z,.no_jump

    ; set jump animation
    ld      a,PLAYER_ANIMATION_JUMP
    ld      [playerAnimation],a
    ret     

.no_jump:

    ; if fall speed > 0 set fall animation
    ld     a,[playerFallSpeed]
    cp     0
    ret    z

    ; set fall animation
    ld      a,PLAYER_ANIMATION_FALL
    ld      [playerAnimation],a
    ret


player_jump:

    ; see if the jump button has been pressed
    ld      a,[coreInput]
    and     %00000001
    jp      z,.not_pressed

    ; check if the player is continuosly pressing the button
    ld      a,[playerJumpPressed]
    cp      1
    jp      z,.still_pressed

    ; otherwise set the button pressed on first press
    ld      a,1
    ld      [playerJumpPressed],a

    ; check if we're in water (and the splash offset is done)
    ld      a,[playerWaterHitDone]
    cp      1
    jp      z,.jump_water

    ; and check if we're on the ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.no_ground

    ; land jump force
    ld      a,PLAYER_JUMP_LAND
    jp      .jump

    ; water jump force
.jump_water:
    ld      a,PLAYER_JUMP_WATER

    ; if we are, set the initial jump force and reset the gravity ticker
.jump:
    ld      [playerJumpForce],a

    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a
    jp      .still_pressed

    ; reset the jump state
.not_pressed:
    ld      a,0
    ld      [playerJumpPressed],a
    ld      [playerWallJumpPressed],a


    ; if we're still pressing the button or are in the air update the jump value
.still_pressed:
.no_ground:

    ; check if we need to move upwards
    ld      a,[playerJumpForce]
    ld      d,a
    cp      0
    ret     z ; we're not moving any longer

    ; check if we're the button was released
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.apply_force ; if not continue applying jump force
    ret     z ; otherwise end here

    ; move player upwards
.apply_force:
    
    ; reset on ground flag
    ld      a,0
    ld      [playerOnGround],a

    ; move player upwards
    ld      a,[playerY]
    
    ; check collision at current top pixel
    call    player_collision_up
    jp      nz,.collision

    ld      a,[playerY]
    dec     a

    ; check again with new top pixel
    call    player_collision_up
    jp      nz,.collision

    ; finally set new top pixel
    ld      a,[playerY]
    dec     a
    ld      [playerY],a

    ; loop until stored jump force reaches 0
    dec     d
    jp      nz,.apply_force 
    ret      

.collision:
    ld      a,0
    ld      [playerJumpPressed],a

    ld      a,[playerJumpForce]
    srl     a
    srl     a
    ld      [playerJumpForce],a
    ret 


player_decrease_jump:

    ; check whether the jump button is still pressed;
    ; if not we decrease the jump force more quickly
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.fast ; fast decrease in case the jump button was released

    ; load current jump force
    ld      a,[playerJumpForce]
    cp      0
    ret     z ; do nothing in case jump is already 0

    ; normal decrease -1
    dec     a
    ld      [playerJumpForce],a

    ; fast decrease /= 2
.fast:
    ld      a,[playerJumpForce]
    srl     a
    ld      [playerJumpForce],a
    ret


player_fall:

    ; check if we're falling at all
    ld      a,[playerFallSpeed]
    ld      d,a ; load the current fall speed as the loop counter
    cp      0
    ret     z

    ; if we're sliding only fall every couple of ticks
    ld      a,[playerWallSlideTick]
    and     PLAYER_SLIDE_SLOWDOWN
    cp      0
    ret     nz

.fall:

    ; check for downward collision
    call    player_collision_down
    jr      nz,.collision ; unlikely jump, thus jr and not jp

    ; reset ground state
    ld      a,0
    ld      [playerOnGround],a
    
    ; increase player position
    ld      a,[playerY]
    inc     a
    ld      [playerY],a
        
    ; loop until stored fall speed reaches 0
    dec     d
    jp      nz,.fall
    jp      .no_collision

.collision:
    ; reset player state to ground after collision
    ld      a,0
    ld      [playerFallSpeed],a
    ld      [playerFallFrames],a
    ld      a,1
    ld      [playerOnGround],a
    ret

.no_collision:

    ; increase the number of frames we were falling
    ld      a,[playerFallFrames]
    cp      $ff
    ret     z ; fall frames max out at 255

    ; increase if not yet at 255
    inc     a
    ld      [playerFallFrames],a
    ret


player_increase_fall:

    ; if we're still jumping do not increase the fall speed
    ld      a,[playerJumpForce]
    cp      0
    ret     nz; do not incrase

    ; if we're in water do not increase the fall speed
    ld      a,[playerInWater]
    cp      0
    ret     nz

    ; otherwise increase it until we reach the maximum
    ld      a,[playerFallSpeed]
    cp      PLAYER_GRAVITY_MAX
    ret     z

    inc     a
    ld      [playerFallSpeed],a
    ret


; Movement --------------------------------------------------------------------
player_accelerate:

    ; check which direction is pressed
    ld      a,[coreInput]
    and     %00100000
    jp      nz,.acc_left

    ld      a,[coreInput]
    and     %00010000
    jp      nz,.acc_right

    ret ; not moving in any direction

.acc_right:
    ld      hl,playerSpeedRight

    ; set player direction
    ld      a,PLAYER_DIRECTION_RIGHT
    ld      [playerDirection],a
    jp      .accelerate

.acc_left:
    ld      hl,playerSpeedLeft

    ; set player direction
    ld      a,PLAYER_DIRECTION_LEFT
    ld      [playerDirection],a

.accelerate:
    ; load speed from corresponding direction variable 
    ld      a,[hl]
    cp      PLAYER_SPEED_MAX ; check if at max speed
    ret     z

    ; if not increase
    inc     a
    ld      [hl],a
    ret



player_decelerate:

    ; only decelerate on every 10th frame
    ; this introduces "lag" or a sliding when turning rapidly
    ld      a,[playerDecTick]
    inc     a
    cp      10
    jp      z,.decrease_right

    ; if not on 10th frame store frame count and return
    ld      [playerDecTick],a
    ret

.decrease_right:

    ; check if right direction is still pressed
    ld      a,[coreInput]
    and     %00010000
    jp      nz,.decrease_left

    ; right
    ld      a,[playerSpeedRight]
    cp      0
    jp      z,.decrease_left
    dec     a
    ld      [playerSpeedRight],a

.decrease_left:

    ; check if left direction is still pressed
    ld      a,[coreInput]
    and     %00100000
    jp      nz,.no_decrease

    ; left
    ld      a,[playerSpeedLeft]
    cp      0
    jp      z,.no_decrease ; if it reached zero we're done

    dec     a
    ld      [playerSpeedLeft],a

.no_decrease:
    ld      a,0
    ld      [playerDecTick],a
    ret


; Movement Logic --------------------------------------------------------------
player_move:

    ; reset wall flag
    ld     a,0
    ld     [playerDirectionWall],a

    ; are we moving at all?
    ld     a,[playerSpeedLeft]
    ld     b,a
    ld     a,[playerSpeedRight]
    add    a,b
    cp     0
    jp     z,.stopped

    ; set walking animation only when on ground
    ld     a,[playerOnGround]
    cp     1
    jp     nz,.not_on_ground

    ld     a,PLAYER_ANIMATION_WALKING
    ld     [playerAnimation],a
    
.not_on_ground:

    ld     a,[playerInWater]
    cp     0
    jp     z,.not_in_water

    ld     a,PLAYER_ANIMATION_SWIMMING
    ld     [playerAnimation],a

    ; half speed when in water
    ld     a,[playerMoveTick]
    cp     1
    jp     nz,.delay
    ld     a,0
    ld     [playerMoveTick],a

.not_in_water:

    ; load x position
    ld     a,[playerX]
    ld     d,a

    ; move right -----------------------------------
.move_right:
    ld     a,[playerSpeedRight]
    cp     0
    jp     z,.move_left
    ld     e,a

.loop_right:

    call   player_collision_right
    jp     z,.not_blocked_right

    ; set wall flag
    ld     a,PLAYER_DIRECTION_RIGHT
    ld     [playerDirectionWall],a

    ; set pushing animation when not in water
    ld     a,[playerInWater]
    cp     0
    jp     z,.pushing_right
    jp     .idle_right

.pushing_right:
    ld     a,PLAYER_ANIMATION_PUSHING
    ld     [playerAnimation],a
    jp     .move_left

.idle_right:
    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    jp     .move_left

.not_blocked_right:
    inc    d
    ld     a,d
    ld     [playerX],a
    dec    e
    jp     nz,.loop_right


    ; move left ------------------------------------
.move_left:
    ld     a,[playerSpeedLeft]
    cp     0
    jp     z,.moved
    ld     e,a

.loop_left:

    call   player_collision_left
    jp     z,.not_blocked_left

    ; set wall flag
    ld     a,PLAYER_DIRECTION_LEFT
    ld     [playerDirectionWall],a

    ; set pushing animation when not in water
    ld     a,[playerInWater]
    cp     0
    jp     z,.pushing_left
    jp      .idle_left

.pushing_left:
    ld     a,PLAYER_ANIMATION_PUSHING
    ld     [playerAnimation],a
    jp     .moved

.idle_left:
    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    jp     .moved

.not_blocked_left:
    dec    d
    ld     a,d
    ld     [playerX],a
    dec    e
    jp     nz,.loop_left


    ; moved ----------------------------------------
.moved:
    ld     a,d
    ld     [playerX],a
    ret    z

.stopped: 

    ; reset to idle animation if on ground
    ld     a,[playerOnGround]
    cp     0
    jp     z,.stopped_water

    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    ret

.stopped_water:
    ld     a,[playerInWater]
    cp     0
    ret    z

    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    ret

.delay:
    inc    a
    ld     [playerMoveTick],a
    ret


; Wall Sliding / Jumping Logic ------------------------------------------------
player_slide_wall:

    ; check if wall jump was performed
    ld     a,[playerWallJumpTick]
    cp     0
    jp     nz,.wall_jump_speed
    
    ; check if on ground
    ld     a,[playerOnGround]
    cp     1
    jp     z,.on_ground
    
    ; check if falling
    ld     a,[playerFallSpeed]
    cp     1
    jp     c,.not_pressing_wall ; if fall speed is <= 1 do not slide

    ; check if pressing against a wall
    ld     a,[playerDirectionWall]
    cp     0
    jp     z,.not_pressing_wall 

    ; check if player is pressing joypad in wall direction
    ld     b,a
    ld     a,[playerDirection]
    cp     b
    jr     nz,.not_pressing_wall

.pressing_wall:
    ld     b,a ; store wall direction

    ; check if already sliding
    ld     a,[playerWallSlideTick]
    cp     0 ; check if not sliding
    jp     nz,.sliding

    ; if pressing against a wall and not sliding and 
    ; directionWall != slideDirection init slide
    ; TODO only allow slide if dir = 0 or after wall jump
    ; in case of wall jump, still do not allow the same wall to be used again
    ld     a,[playerWallSlideDir]
    cp     b
    ret    z ; exit if same direction

    ; check if player fully touches the wall before initiating a slide
    ld     a,[playerDirection]
    cp     PLAYER_DIRECTION_RIGHT
    jp     z,.slide_right

.slide_left:
    call   player_collision_left_all
    ret    z
    call   player_slide_wall_init
    ret

.slide_right:
    call   player_collision_right_all
    ret    z
    call   player_slide_wall_init
    ret


.sliding:

    ; if sliding for more than X frames end slide
    cp     PLAYER_SLIDE_DURATION
    jp     z,.sliding_done

    ; otherwise continue sliding
    inc    a
    ld     [playerWallSlideTick],a

    ; set animation
    ld     a,PLAYER_ANIMATION_SLIDE
    ld     [playerAnimation],a
    ret


.sliding_done:

    call    player_slide_wall_stop
    ld      a,0
    ld      [playerWallSlideTick],a

    ld      a,PLAYER_WALL_JUMP_WINDOW
    ld      [playerWallJumpWindow],a
    ret


.not_pressing_wall:

    ; check wall jump window
    ld      a,[playerWallJumpWindow]
    cp      0
    jp      nz,.check_wall_jump

    ; if sliding and no longer pressing, end slide
    ld      a,[playerWallSlideTick]
    cp      0 
    ret     z ; if not sliding, do nothing

    ; otherwise stop the slide and set the correct direction
    call    player_slide_wall_stop

    ; we have X frames where a wall jump can be executed by pressind
    ; the joypad away from the last jump direction and pressing the jump
    ; button at the same time
    ld      a,PLAYER_WALL_JUMP_WINDOW
    ld      [playerWallJumpWindow],a
            
    ret


.on_ground:

    ; if we didnt slide we dont need to reset
    ld      a,[playerWallSlideDir]
    cp      0
    ret     z

    ; otherwise reset the sliding state and switch the direction
    call    player_slide_wall_stop
    ld      a,0
    ld      [playerWallSlideDir],a

    ret


.check_wall_jump:

    ; decrease window for wall jump
    ld      a,[playerWallJumpWindow]
    dec     a
    ld      [playerWallJumpWindow],a

    ; check last wall direction against player direction, must be different
    ld      a,[playerDirection]
    ld      b,a
    ld      a,[playerWallSlideDir]
    cp      b
    ret     z ; player must press joypad away from the wall he slided on, otherwise return

    ; check if button was hold down since the last jump, if so don't jump again
    ld      a,[playerWallJumpPressed]
    cp      1
    ret     z

    ; check if jump button got pressed
    ld      a,[coreInput]
    and     %00000001
    ret     z

    ; set up jump force and reset fall speed
    ld      a,PLAYER_JUMP_WALL
    ld      [playerJumpForce],a

    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

    ld      a,0
    ld      [playerFallFrames],a
    ld      [playerFallSpeed],a
    ld      [playerWallJumpWindow],a

    ; setup forced movement away from the wall
    ld      a,[playerWallSlideDir]
    ld      [playerWallJumpDir],a

    ld      a,PLAYER_WALL_JUMP_DURATION
    ld      [playerWallJumpTick],a

    ; set up jump button state
    ld      a,1
    ld      [playerWallJumpPressed],a

    ret


.wall_jump_speed:
    
    ; decrease ticks left for wall jump speed boost
    ld      a,[playerWallJumpTick]
    dec     a
    ld      [playerWallJumpTick],a
    cp      0
    jp      z,.stop

    ; modify player speed variable
    ld      a,[playerWallJumpDir]
    cp      PLAYER_DIRECTION_LEFT
    jp      z,.right

.left:
    ld      a,2
    ld      [playerSpeedLeft],a
    ld      a,0
    ld      [playerSpeedRight],a
    ret

.right:
    ld      a,2
    ld      [playerSpeedRight],a
    ld      a,0
    ld      [playerSpeedLeft],a
    ret

.stop:
    ld      a,0
    ld      [playerSpeedRight],a
    ld      [playerSpeedLeft],a
    ret


player_slide_wall_init:
    ld      a,[playerDirectionWall]
    ld      [playerWallSlideDir],a
    ld      a,20
    ld      [playerWallSlideTick],a
    ret


player_slide_wall_stop:

    ; avoid graphical glitches when switching animation and direction
    ld      a,PLAYER_ANIMATION_FALL
    ld      [playerAnimation],a

    ; reset tick
    ld      a,0
    ld      [playerWallSlideTick],a
    ld      [playerWallJumpWindow],a

    ret



; Animation Updates -----------------------------------------------------------
player_animate:

    ; check for animation changes
    ld      a,[playerAnimationLast]
    ld      b,a
    ld      a,[playerAnimation]
    cp      b
    jp      z,.no_animation_change
    
    ; switch to new animation
    ld      b,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_set
    call    sprite_animation_start
    ld      a,b
    ld      [playerAnimationLast],a

.no_animation_change:

    ; check for direction changes
    ld      a,[playerDirectionLast]
    ld      b,a
    ld      a,[playerDirection]
    cp      b
    jp      z,.no_direction_change

    ; switch to new direction
    cp      PLAYER_DIRECTION_RIGHT
    jp      z,.direction_right

.direction_left:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_unset_mirror
    jp      .direction_changed

.direction_right:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_mirror
    jp      .direction_changed

.direction_changed:

    ; reset animation frame
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_start

    ld      a,[playerDirection]
    ld      [playerDirectionLast],a

.no_direction_change:
    ret


; Sleep Timer -----------------------------------------------------------------
player_sleep:

    ; in case no button is pressed decrease the sleep ticker 
    ld      a,[coreInput]
    and     %00110001
    jp      nz,.active

    ; also check whether we're on the ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.active

    ; check sleep ticker
    ld      a,[playerSleepTick]
    cp      0
    ret     nz

    ; set sleeping
    ld      a,PLAYER_ANIMATION_SLEEP
    ld      [playerAnimation],a
    ret

.active:
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a
    ret


player_sleep_timer:
    ld      a,[playerSleepTick]
    cp      0
    ret     z

    dec     a
    ld      [playerSleepTick],a
    ret

