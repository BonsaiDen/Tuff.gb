; Constants -------------------------------------------------------------------
PLAYER_DIRECTION_LEFT      EQU 1
PLAYER_DIRECTION_RIGHT     EQU 2

PLAYER_JUMP_MAX            EQU 2
PLAYER_FALL_MAX            EQU 4
PLAYER_SPEED_MAX           EQU 1
PLAYER_GRAVITY_MAX         EQU 3

PLAYER_GRAVITY_INTERVAL    EQU 9

PLAYER_SLEEP_WAIT          EQU 180
PLAYER_SPRITE_INDEX        EQU 0

PLAYER_ANIMATION_IDLE      EQU 0
PLAYER_ANIMATION_WALKING   EQU 1
PLAYER_ANIMATION_SLEEP     EQU 2
PLAYER_ANIMATION_PUSHING   EQU 3
PLAYER_ANIMATION_JUMP      EQU 4
PLAYER_ANIMATION_FALL      EQU 5



; Player ----------------------------------------------------------------------
player_init:

    ; Position 
    ld      a,32
    ld      [playerX],a
    ld      [playerY],a

    ; Direction
    ld      a,PLAYER_DIRECTION_RIGHT
    ld      [playerDirection],a
    ld      a,255
    ld      [playerDirectionLast],a

    ; Animation
    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    ld      a,255
    ld      [playerAnimationLast],a


    ; Jumping / Falling
    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

    ld      a,0
    ld      [playerJumpForce],a
    ld      [playerJumpPressed],a
    ld      [playerFallSpeed],a

    ld      a,1
    ld      [playerOnGround],a

    ; Movement
    ld      a,0
    ld      [playerSpeedRight],a
    ld      [playerSpeedLeft],a
    ld      [playerDecTick],a

    ; Other
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a

    ; Sprite
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_enable

    ret


; Player Logic ----------------------------------------------------------------
player_update:

    ; only update player every 1.5 frames
    ld      a,[playerTick]
    cp      0
    jp      nz,.no_update

    ; control / animation
    call    player_accelerate
    call    player_decelerate
    call    player_move
    call    player_gravity
    call    player_sleep
    call    player_animate
    call    player_scroll_map

    ; update sprite position
    ld      a,[playerX]
    ld      b,a
    ld      a,[playerY]
    ld      c,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_position

    ; every other tick we switch the delay between 0 or 1 to 
    ; emulate moving by 1.5 pixels every frame
    ld      a,[playerTickSwitch]
    ld      [playerTick],a

    ; switch between 0 and 1
    ld      a,[playerTickSwitch]
    xor     a
    ld      [playerTickSwitch],a

    jp      .updated

.no_update:
    dec     a
    ld      [playerTick],a

.updated:
    ret


; Player Collisions -----------------------------------------------------------
player_collision_up:
    ld      a,[playerY]
    cp      27
    ret

player_collision_down:
    ld      a,[playerY]
    cp      48
    ;ld       a,0
    ;cp       1
    ret

player_collision_left:
    ;ld      a,[playerX]
    ;cp      5
    ld       a,0
    cp       1
    ret

player_collision_right:
    ;ld      a,[playerX]
    ;cp      155
    ld       a,0
    cp       1
    ret


; Handle Map Scrolling --------------------------------------------------------
player_scroll_map:

    ; left ------------------------------
    ld      a,[playerX]
    cp      1 ; < 1
    jp      nc,.check_right
    call    map_scroll_left

    ld      a,159
    ld      [playerX],a
    jp      .done


    ; right -----------------------------
.check_right:
    ld      a,[playerX]
    cp      159 ; > 159
    jp      c,.check_up
    call    map_scroll_right

    ld      a,2
    ld      [playerX],a
    jp      .done


    ; up --------------------------------
.check_up:
    ld      a,[playerY]
    cp      1 ; < 1
    jp      nc,.check_down
    call    map_scroll_up

    ld      a,142
    ld      [playerY],a
    jp      .done


    ; down ------------------------------
.check_down:
    ld      a,[playerY]
    cp      143 ; > 140
    jp      c,.done
    call    map_scroll_down

    ld      a,2
    ld      [playerY],a
    jp      .done

.done:
    ret


; Gravity ---------------------------------------------------------------------
player_gravity:

    ; only increase / decrease gravity every PLAYER_GRAVITY_INTERVAL ticks
    ld      a,[playerGravityTick]
    dec     a
    ld      [playerGravityTick],a

    ; check if the ticker reached 0
    cp      0
    jp      nz,.no_tick

    ; update gravity
    call    player_decrease_jump
    call    player_increase_fall

    ; reset ticker
    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

.no_tick:

    call   player_fall
    call   player_jump

    ; if jump force > 0 set jump animation
    ld     a,[playerJumpForce]
    cp     0
    jp     z,.no_jump

    ; set jump animation
    ld      a,PLAYER_ANIMATION_JUMP
    ld      [playerAnimation],a
    jp     .done

.no_jump:

    ; if fall speed > 0 set fall animation
    ld     a,[playerFallSpeed]
    cp     0
    jp     z,.done

    ; set fall animation
    ld      a,PLAYER_ANIMATION_FALL
    ld      [playerAnimation],a
    jp     .done

.done:
    ret


player_jump:

    ; see if the jump button has been pressed
    ld      a,[inputState]
    and     %00000001
    jp      z,.not_pressed

    ; check if the player is continuosly pressing the button
    ld      a,[playerJumpPressed]
    cp      1
    jp      z,.still_pressed

    ; otherwrise set the button pressed on first press
    ld      a,1
    ld      [playerJumpPressed],a

    ; and check if we're on the ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.no_ground

    ; if we are, set the initial jump force and reset the gravity ticker
    ld      a,PLAYER_JUMP_MAX
    ld      [playerJumpForce],a

    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a
    jp      .still_pressed


    ; reset the jump state
.not_pressed:
    ld      a,0
    ld      [playerJumpPressed],a


    ; if we're still pressing the button or are in the air update the jump value
.still_pressed:
.no_ground:

    ; check if we need to move upwards
    ld      a,[playerJumpForce]
    ld      b,a
    cp      0
    jp      z,.done

    ; check if we're the button was released
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.apply_force

    ; if so quickly reduce the jump force
    jp      .done

    ; move player upwards
.apply_force:
    
    ; reset on ground flag
    ld      a,0
    ld      [playerOnGround],a

    ; move player upwards
    ld      a,[playerY]
    dec     a
    ld      [playerY],a
    
    ; check collision
    call    player_collision_up
    jp      z,.collision

    ; loop until stored jump force reaches 0
    dec     b
    ld      a,b
    cp      0
    jp      nz,.apply_force
    jp      .done

.collision:
    ld      a,0
    ld      [playerJumpPressed],a

    ld      a,[playerJumpForce]
    srl     a
    srl     a
    ld      [playerJumpForce],a

.done:
    ret


player_decrease_jump:

    ; check whether the jump button is still pressed;
    ; if not we decrease the jump force more quickly
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.fast

    ; normal decrease -1
    ld      a,[playerJumpForce]
    cp      0
    jp      z,.done

    dec     a
    ld      [playerJumpForce],a

    ; fast decrease /= 2
.fast:
    ld      a,[playerJumpForce]
    srl     a; TODO update
    ld      [playerJumpForce],a

.done:
    ret


player_fall:

    ld      a,[playerFallSpeed]
    ld      b,a ; load the current fall speed as the loop counter
    cp      0
    jp      z,.done ; if the fall speed is zero do nothing

.fall:

    call    player_collision_down
    jp      z,.collision

    ; reset ground state
    ld      a,0
    ld      [playerOnGround],a
    
    ; increase player position
    ld      a,[playerY]
    inc     a
    ld      [playerY],a
        
    ; loop until stored fall speed reaches 0
    dec     b
    ld      a,b
    cp      0
    jp      nz,.fall
    jp      .done

.collision:
    ld      a,0
    ld      [playerFallSpeed],a
    ld      a,1
    ld      [playerOnGround],a

.done:
    ret


player_increase_fall:

    ; if we're still jumping do not increase the fall speed
    ld      a,[playerJumpForce]
    cp      0
    jp      nz,.no_increase

    ; otherwise increase it untiul we reach the maximum
    ld      a,[playerFallSpeed]
    cp      PLAYER_GRAVITY_MAX
    jp      z,.no_increase

    inc     a
    ld      [playerFallSpeed],a

.no_increase:
    ret



; Movement --------------------------------------------------------------------
player_accelerate:

    ; check which direction is pressed
    ld      a,[inputState]
    cp      %00100000
    jp      z,.left
    cp      %00010000
    jp      z,.right

    ; not moving
    jp      .done

.right:
    ld      hl,playerSpeedRight
    ld      b,PLAYER_DIRECTION_RIGHT
    jp      .accelerate

.left:
    ld      hl,playerSpeedLeft
    ld      b,PLAYER_DIRECTION_LEFT

.accelerate:

    ; set player direction
    ld      a,b
    ld      [playerDirection],a

    ; load speed variable
    ld      a,[hl]

    ; check if max speed
    cp      PLAYER_SPEED_MAX
    jp      z,.done

    ; if not increase
    inc     a
    ld      [hl],a

.done:
    ret


player_decelerate:

    ; only decelerate on every 10th frame
    ld      a,[playerDecTick]
    inc     a
    cp      10
    jp      nz,.no_tick

.decrease_right:

    ; check if right direction is still pressed
    ld      a,[inputState]
    and     %00010000
    jp      nz,.decrease_left

    ; right
    ld      a,[playerSpeedRight]
    cp      0
    jp      z,.decrease_left
    dec     a
    ld      [playerSpeedRight],a

.decrease_left:

    ; check if left direction is still pressed
    ld      a,[inputState]
    and     %00100000
    jp      nz,.done

    ; left
    ld      a,[playerSpeedLeft]
    cp      0
    jp      z,.done
    dec     a
    ld      [playerSpeedLeft],a

    jp      .done

.done:
    ld      a,0

.no_tick:
    ld      [playerDecTick],a
    ret


; Movement Logic --------------------------------------------------------------
player_move:

    ; are we moving at all?
    ld     a,[playerSpeedLeft]
    ld     b,a
    ld     a,[playerSpeedRight]
    add    a,b
    cp     0
    jp     z,.stopped

    ld     a,PLAYER_ANIMATION_WALKING
    ld     [playerAnimation],a
    
    ; load x position
    ld     a,[playerX]
    ld     b,a
    ld     d,a ; store old x position

    ; move right -----------------------------------
    ld     a,[playerSpeedRight]
    ld     c,a

.loop_right:

    call   player_collision_right
    jp     nz,.not_blocked_right

    ld     a,PLAYER_ANIMATION_PUSHING
    ld     [playerAnimation],a
    jp     .move_left

.not_blocked_right:

    ; TODO check X collision
    inc    b
    dec    c
    ld     a,c
    cp     0
    jp     nz,.loop_right



    ; move left ------------------------------------
.move_left:
    ld     a,[playerSpeedLeft]
    ld     c,a

.loop_left:

    call   player_collision_left
    jp     nz,.not_blocked_left

    ld     a,PLAYER_ANIMATION_PUSHING
    ld     [playerAnimation],a
    jp     .moved

.not_blocked_left:
    dec    b
    dec    c
    ld     a,c
    cp     0
    jp     nz,.loop_left

.moved:
    ; store new x position
    ld     a,b
    ld     [playerX],a
    jp     .done

.stopped: ; reset to idle animation
    ld     a,PLAYER_ANIMATION_IDLE
    ld     [playerAnimation],a
    jp     .done

.done:
    ret



; Animation Updates -----------------------------------------------------------
player_animate:

    ; check for animation changes
    ld      a,[playerAnimationLast]
    ld      b,a
    ld      a,[playerAnimation]
    cp      b
    jp      z,.no_animation_change
    
    ; switch to new animation
    ld      b,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_set
    call    sprite_animation_start
    ld      a,b
    ld      [playerAnimationLast],a

.no_animation_change:

    ; check for direction changes
    ld      a,[playerDirectionLast]
    ld      b,a
    ld      a,[playerDirection]
    cp      b
    jp      z,.no_direction_change

    ; switch to new direction
    cp      PLAYER_DIRECTION_RIGHT
    jp      z,.direction_right

.direction_left:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_unset_mirror
    jp      .direction_changed

.direction_right:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_mirror
    jp      .direction_changed

.direction_changed:

    ; reset animation frame
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_start

    ld      a,[playerDirection]
    ld      [playerDirectionLast],a

.no_direction_change:
    ret


; Sleep Timer -----------------------------------------------------------------
player_sleep:

    ; in case no button is pressed decrease the sleep ticker 
    ld      a,[inputState]
    and     %00110001
    jp      nz,.active

    ; check sleep ticker
    ld      a,[playerSleepTick]
    cp      0
    jp      nz,.waiting ; already sleeping

    ; set sleeping
    ld      a,PLAYER_ANIMATION_SLEEP
    ld      [playerAnimation],a
    jp      .done

.waiting:
    dec     a
    ld      [playerSleepTick],a
    jp      .done

.active:
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a
    jp      .done

.done:
    ret

