SECTION "PlayerLogic",ROM0

; Player ----------------------------------------------------------------------
player_init:

    ; Position 
    ld      a,24
    ld      [playerX],a
    ld      a,62
    ld      [playerY],a

    ; Direction
    ld      a,PLAYER_DIRECTION_RIGHT
    ld      [playerDirection],a
    ld      a,0
    ld      [playerDirectionLast],a

    ; Animation
    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    ld      a,255
    ld      [playerAnimationLast],a

    ; Jumping / Falling
    call    player_reset

    ; Sprite
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_enable
    ld      b,0
    call    sprite_set_tile_offset

    ; Load initial sprite data
    call    player_update_sprite_row

    ret


player_reset:

    ; Gravity
    ld      a,1
    ld      [playerGravityTick],a
    ld      a,PLAYER_GRAVITY_MAX
    ld      [playerGravityMax],a

    ld      a,0
    ld      [playerJumpForce],a
    ld      [playerJumpPressed],a
    ld      [playerFallSpeed],a
    ld      [playerUnderWater],a
    ld      [playerWasUnderWater],a
    ld      [playerIsPounding],a
    ld      [playerInWater],a

    ld      a,1
    ld      [playerOnGround],a

    ; Movement
    ld      a,0
    ld      [playerSpeedRight],a
    ld      [playerSpeedLeft],a
    ld      [playerDecTick],a
    ld      [playerMoveTick],a
    ld      [playerLandingFrames],a
    ld      [playerWaterTick],a

    ; Sliding
    ld      a,0
    ld      [playerDirectionWall],a
    ld      [playerWallSlideDir],a
    ld      [playerWallSlideTick],a
    ld      [playerWallJumpPressed],a
    ld      [playerWallJumpTick],a

    ; Other
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a

    ld      a,255
    ld      [playerDissolveTick],a

    ret



; Player Logic ----------------------------------------------------------------
player_update:

    ; check if we're dissolving
    ld      a,[playerDissolveTick]
    cp      255
    jp      z,.control

    ; wait for 25 ticks before flashing screen and resetting player position
    ld      a,[playerY]
    add     2
    ld      [playerYOffset],a

    ld      a,[playerDissolveTick]
    inc     a
    ld      [playerDissolveTick],a
    cp      30
    jp      nz,.update

    ld      a,255
    ld      [playerDissolveTick],a

    call    screen_flash_fast_light
    call    save_reset_player
    ret


    ; control / animation
.control:

    ; ignore when pounding
    ld      a,[playerIsPounding]
    cp      0
    jp      nz,.pounding

    call    player_accelerate
    call    player_decelerate
    call    player_move

.pounding:

    ; check for hazard (checked before gravity so we actually overlap a few pixels)
    ld      a,[mapCollisionFlag]
    cp      4
    jp      z,player_dissolve

    ; pounding logic
    call    player_pound

    ; Jumping / Falling
    call    player_gravity
    call    player_slide_wall

    ; check for hazard
    ld      a,[mapCollisionFlag]
    cp      4
    jp      z,player_dissolve

    call    player_scroll_map
    call    player_sleep

    ; y position for sprite
    ld      a,[playerY]
    ld      [playerYOffset],a

    ; now check for shallow water (swimming)
    ld      a,[playerY]
    sub     5
    ld      c,a
    ld      a,[playerX]
    ld      b,a
    call    map_get_collision

    ld      a,[mapCollisionFlag]
    cp      3
    jr      z,.under_water

    ; check if swimming
    cp      2 
    jr      z,.water

    ; check if was diving
    ld      a,[playerWasUnderWater]
    cp      1
    jp      nz,.check_diving

    ; detect surfacing
    ld      a,0
    ld      [playerUnderWater],a
    ld      [playerInWater],a
    jp      .water


    ; check for deep water (diving)
.check_diving:
    ld      a,[playerY]
    ld      c,a
    ld      a,[playerX]
    ld      b,a
    call    map_get_collision
    ld      a,[mapCollisionFlag]
    cp      3
    jr      z,.under_water


.check_hazard:
    cp      4
    jp      z,player_dissolve

    ; reset water variables when on land
.land:
    ld      a,0
    ld      [playerInWater],a
    ld      [playerUnderWater],a
    ld      [playerWaterHitDone],a
    jp      .update

.under_water:
    ld      a,1
    ld      [playerUnderWater],a
    ld      [playerWasUnderWater],a
    jp      .water

.water:
    call    player_water_update

    ; swim animation
    ld      a,[playerUnderWater]
    cp      1
    jp      nz,.update

    ; do not overwrite pounding
    ld      a,[playerIsPounding]
    cp      0
    jp      nz,.update

    ; set swim animation when moving underwater
    ld      a,[coreInput]
    and     %00110000
    cp      0
    jp      z,.water_idle

    ; dont set animation when moving up / down
    ld      a,[coreInput]
    and     %00000011
    cp      0
    jp      nz,.water_idle

    ld      a,PLAYER_ANIMATION_SWIMMING
    ld      [playerAnimation],a

    jp      .update

    ; set idle animation in case neither a / b is pressed
.water_idle:
    ld      a,[coreInput]
    and     %00000011
    cp      0
    jp      nz,.update

    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a

    ; animation / other logic
.update:
    call    player_animate

    ; update player sprite position
    ld      a,[playerX]
    ld      b,a
    ld      a,[playerYOffset]
    ld      c,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_position

    ret     


player_set_position:
    ; update player sprite position
    ld      a,[playerX]
    ld      b,a
    ld      a,[playerY]
    ld      c,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_position
    ret


player_dissolve:

    ; jump out if already dissolving
    ld      a,[playerDissolveTick]
    cp      255
    jp      nz,.done

    ; dissolve player when hitting a hazard
    ld      a,PLAYER_ANIMATION_DISSOLVE
    ld      [playerAnimation],a
    ld      a,0
    ld      [playerDissolveTick],a
    ld      [mapCollisionFlag],a

.done:
    ret


; Player Water Movement -------------------------------------------------------
playerWaterSwimOffsetTable:
    DB      1,1,2,2,1,1,0,0,1,1,2,2,1,1,0,0

playerWaterHitOffsetTable:
    DB      1,2,3,4,6,7,8,9,10,8,7,7,6,6,6,5,5,5,5,4
    DB      4,4,4,3,3,3,3,3,2,2,2,2,2,1,1,1


player_water_update:

    ; check for the intitial frame on which we hit the water
    ld      a,[playerInWater]
    cp      0
    jp      nz,.not_initial

    ; save speed
    ld      a,[playerFallFrames]
    ld      [playerWaterHitDepth],a

    ld      a,1
    ld      [playerInWater],a

    ld      a,0
    ld      [playerFallFrames],a

    ; check if we were previously under water, if so skip water offset
    ld      a,[playerWasUnderWater]
    cp      1
    jp      nz,.not_initial

    ; if we are surfacing skip the offset, and correct the player y position
    ld      a,7
    ld      [playerWaterTick],a

    ld      a,1
    ld      [playerWaterHitDone],a
    ld      [playerGravityTick],a

    ld      a,0
    ld      [playerWasUnderWater],a
    ld      [playerUnderWater],a
    ld      [playerJumpForce],a

    ; correct y position
    ld      a,[playerY]
    and     %11111000
    add     5
    ld      [playerY],a


.not_initial:

    ; ignore water physics while pounding
    ld      a,[playerIsPounding]
    cp      0
    ret     nz

    ; prevent sleep and reset fall speed
    ld      a,0
    ld      [playerSleepTick],a

    ; swim downwards / dive in
    ;ld      a,[playerUnderWater]
    ;cp      1
    ;jp      nz,.stop_fall

    ; check button
    ld      a,[coreInput]
    and     %00000010
    cp      %00000010
    jp      nz,.stop_fall

    ; animation and speed
    ld      a,PLAYER_ANIMATION_FALL
    ld      [playerAnimation],a

    ld      a,PLAYER_JUMP_SWIM
    ld      [playerFallSpeed],a
    jp      .offset

.stop_fall:
    ld      a,0
    ld      [playerFallSpeed],a

    ; check swimming offset or initial hit offset
.offset:
    ld      a,[playerWaterHitDone]
    cp      1
    jp      z,.animate_water
    
    ; initial "splash / hit" offset
    ld      a,[playerWaterTick]
    cp      PLAYER_WATER_OFFSET_MAX; check if we're done
    jr      z,.water_hit_done

    ld      a,[playerWaterTick]
    inc     a
    ld      [playerWaterTick],a

    ; load the y offset for the splash
    ld      hl,playerWaterHitOffsetTable
    ld      b,0
    ld      c,a
    add     hl,bc

    ; set diving / surfacing animation
    cp      14
    jp      c,.down
    ld      a,PLAYER_ANIMATION_SURFACE
    jp      .animate
.down:
    ld      a,PLAYER_ANIMATION_FALL

.animate:
    ld      [playerAnimation],a

    ; load y offset value
    ld      a,[hl]
    ld      b,a

    ; adjust the depth based on the fall speed
    ld      a,[playerWaterHitDepth]
    cp      15
    jp      nc,.fast
    srl     b; divice depth by 2 if speed was low

    ; apply
.fast:
    ld      a,[playerY] 
    add     b
    ld      [playerYOffset],a
    ret

.water_hit_done:
    ld      a,1
    ld      [playerWaterHitDone],a
    ld      a,7; set the value so the first movement after the splash is up
    ld      [playerWaterTick],a
    ret 


    ; swimming offset
.animate_water:

    ; load y offset from table
    ld      a,[playerWaterTick]
    ld      hl,playerWaterSwimOffsetTable
    ld      b,0
    ld      c,a
    add     hl,bc
    ld      a,[hl]
    ld      b,a

    ld      a,[playerWaterTick]
    cp      8
    jp      c,.move_down ; if 4 is greater than the tick, move the player down (0, 1, 2, 3)

.move_up: ; move the player up, 4, 5, 6, 7
    ld      a,[playerY] 
    sub     b
    ld      [playerYOffset],a
    ret

.move_down:
    ld      a,[playerY]
    add     b
    ld      [playerYOffset],a
    ret


player_water_timer:

    ; check if in water
    ld      a,[playerInWater]
    cp      0
    jp      z,.done

    ; check if we've finished the initial splash offseting
    ld      a,[playerWaterHitDone]
    cp      0
    ret     z

    ; update offset tick 
.tick:
    ld      a,[playerWaterTick]
    inc     a
    cp      16
    jp      nz,.done
    jp      c,.done
    ld      a,0

.done:
    ld      [playerWaterTick],a
    ret


; Player Collisions -----------------------------------------------------------

; if a collision is detected these will unset the zero flag  (nz = col, z = nocol)
; call     player_collision_up
; jp       nz, .collided 
player_collision_up: 

    ; different height when diving
    ld      a,[playerUnderWater]
    cp      1
    jp      z,.diving
    ld      e,PLAYER_HEIGHT
    jp      .check

.diving:
    ld      e,PLAYER_HEIGHT + 2

.check:
    ; middle
    ld      a,[playerY]
    sub     e
    ld      c,a

    ld      a,[playerX]
    ld      b,a
    call    map_get_collision
    ret     nz

    ; right half 
    ld      a,[playerY]
    sub     e
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 3
    ld      b,a
    call    map_get_collision
    ret     nz

    ; left half 
    ld      a,[playerY]
    sub     e
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret


player_collision_down: 

    ; different height when diving
    ld      a,[playerUnderWater]
    cp      1
    jp      z,.diving
    ld      e,0
    jp      .check

.diving:
    ld      e,2

.check:

    ; middle
    ld      a,[playerY]
    add     e
    ld      c,a

    ld      a,[playerX]
    ld      b,a
    call    map_get_collision
    ret     nz

    ; right half 
    ld      a,[playerY]
    add     e
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 3
    ld      b,a
    call    map_get_collision
    ret     nz

    ; left half 
    ld      a,[playerY]
    add     e
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret     


player_collision_left:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     nz

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     nz

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    ret     


player_collision_right:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    ret     nz

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    ret     nz

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision

    ret


; Wall Jump Collision Checks --------------------------------------------------
player_collision_left_all:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    sub     PLAYER_HALF_WIDTH - 1
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision
    
    ; set collision flag
    or      1 ; set nz
    ret

.no_collision:
    cp      a ; set z
    ret     


player_collision_right_all:

    ; middle
    ld      a,[playerY]
    sub     a,7
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; upper half 
    ld      a,[playerY]
    sub     a,PLAYER_HEIGHT - 1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; lower half 
    ld      a,[playerY]
    sub     1
    ld      c,a

    ld      a,[playerX]
    add     PLAYER_HALF_WIDTH - 2
    ld      b,a
    call    map_get_collision
    jr      z,.no_collision

    ; set collision flag
    or      1 ; set nz
    ret

.no_collision:
    cp      a ; set z
    ret     


; Handle Map Scrolling --------------------------------------------------------
player_scroll_map:

    ; left ------------------------------
    ld      a,[playerX]
    cp      2 ; < 1
    jp      nc,.check_right

    ld      a,157
    ld      [playerX],a
    call    player_set_position
    call    map_scroll_left

    jp      .done


    ; right -----------------------------
.check_right:
    ld      a,[playerX]
    cp      158 ; > 159
    jp      c,.check_up

    ld      a,3
    ld      [playerX],a
    call    player_set_position
    call    map_scroll_right

    jp      .done


    ; up --------------------------------
.check_up:
    ld      a,[playerY]
    cp      2 ; < 1
    jp      nc,.check_down

    ; add a boost to the jump to we can reach a platform or something
    ld      a,[playerUnderWater]
    cp      1
    jp      z,.up_water

    ld      a,PLAYER_JUMP_SCREEN_BOOST
    ld      [playerJumpForce],a

    ld      a,PLAYER_GRAVITY_INTERVAL / 2
    ld      [playerGravityTick],a

.up_water:
    ld      a,125
    ld      [playerY],a

    call    player_set_position
    call    map_scroll_up

    jp      .done


    ; down ------------------------------
.check_down:
    ld      a,[playerY]
    cp      126 ; 
    jp      c,.done

    ld      a,3
    ld      [playerY],a
    call    player_set_position
    call    map_scroll_down

    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

.done:
    ret


; Gravity ---------------------------------------------------------------------
player_gravity:

    ld      a,[playerLandingFrames]
    cp      0
    ret     nz

    ; only increase / decrease gravity every PLAYER_GRAVITY_INTERVAL ticks
    ld      a,[playerGravityTick]
    dec     a
    ld      [playerGravityTick],a

    ; check if the ticker reached 0
    cp      0
    jp      nz,.no_tick

    ; update gravity
    call    player_decrease_jump
    call    player_increase_fall

    ; reset ticker
    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a
            
.no_tick:

    ; if under water half movement speed by 2
    ld      a,[playerWasUnderWater]
    cp      0
    jp      z,.move

    ld      a,[playerGravityTick]
    and     %00000001
    cp      0
    jp      nz,.delay_move

.move:
    call    player_fall
    call    player_jump

.delay_move:

    ; if jump force > 0 set jump animation
    ld      a,[playerJumpForce]
    cp      0
    jp      z,.no_jump

    ; set jump animation
    ld      a,PLAYER_ANIMATION_JUMP
    ld      [playerAnimation],a
    ret     

.no_jump:

    ; if fall speed > 0 set fall animation
    ld     a,[playerFallSpeed]
    cp     0
    ret    z

    ; set fall animation
    ld      a,[playerIsPounding]
    cp      0
    ret     nz

    ; skip the animation when under water
    ; otherwise pressing against a ceiling will result in flicker
    ld      a,[playerUnderWater]
    cp      1
    ret     z

    ld      a,PLAYER_ANIMATION_FALL
    ld      [playerAnimation],a
    ret


player_jump:

    ; check for landing frames
    ld      a,[playerLandingFrames]
    cp      0
    ret     nz

    ; see if the jump button has been pressed
    ld      a,[coreInput]
    and     %00000001
    jp      z,.not_pressed

    ; check if the player is continuosly pressing the button
    ld      a,[playerJumpPressed]
    cp      1
    jp      z,.still_pressed

    ; otherwise set the button pressed on first press
    ld      a,1
    ld      [playerJumpPressed],a

    ; under water movement
    ld      a,[playerUnderWater]
    cp      1
    jp      z,.jump_swim

    ; check if we're in water (and the splash offset is done)
    ld      a,[playerWaterHitDone]
    cp      1
    jp      z,.jump_water

    ; and check if we're on the ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.no_ground

    ; land jump force 
    ld      a,PLAYER_JUMP_FORCE
    ld      [playerJumpForce],a
    ld      a,PLAYER_GRAVITY_INTERVAL
    jp      .jump

    ; water jump force
.jump_water:
    ld      a,PLAYER_JUMP_FORCE
    ld      [playerJumpForce],a
    ld      a,0; unset under water flag when jumping out of water
    ld      [playerWasUnderWater],a
    ld      a,6 ; setup gravity tick delay so we do not jump as high as normally
    jr      .jump

.jump_swim:
    ld      a,PLAYER_JUMP_SWIM
    ld      [playerJumpForce],a
    ld      a,2 ; setup gravity tick delay

    ; if we are, set the initial jump force and reset the gravity ticker
.jump:
    ld      [playerGravityTick],a
    jp      .still_pressed

    ; reset the jump state
.not_pressed:
    ld      a,0
    ld      [playerJumpPressed],a
    ld      [playerWallJumpPressed],a


    ; if we're still pressing the button or are in the air update the jump value
.still_pressed:
.no_ground:

    ; check if we need to move upwards
    ld      a,[playerJumpForce]
    ld      d,a
    cp      0
    ret     z ; we're not moving any longer

    ; check if we're the button was released
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.apply_force ; if not continue applying jump force
    ret     z ; otherwise end here

    ; move player upwards
.apply_force:
    
    ; reset on ground flag
    ld      a,0
    ld      [playerOnGround],a

    ; move player upwards
    ld      a,[playerY]
    
    ; check collision at current top pixel
    call    player_collision_up
    jp      nz,.collision

    ld      a,[playerY]
    dec     a

    ; check again with new top pixel
    call    player_collision_up
    jp      nz,.collision

    ; finally set new top pixel
    ld      a,[playerY]
    dec     a
    ld      [playerY],a

    ; loop until stored jump force reaches 0
    dec     d
    jp      nz,.apply_force 
    ret      

.collision:
    ld      a,0
    ld      [playerJumpPressed],a

    ld      a,[playerJumpForce]
    srl     a
    srl     a
    ld      [playerJumpForce],a
    ret 


player_decrease_jump:

    ; check if under water
    ld      a,[playerUnderWater]
    cp      1
    ret     z

    ; check whether the jump button is still pressed;
    ; if not we decrease the jump force more quickly
    ld      a,[playerJumpPressed]
    cp      0
    jp      nz,.fast ; fast decrease in case the jump button was released

    ; load current jump force
    ld      a,[playerJumpForce]
    cp      0
    ret     z ; do nothing in case jump is already 0

    ; normal decrease -1
    ld      a,[playerJumpForce]
    dec     a
    ld      [playerJumpForce],a

    ; fast decrease /= 2
.fast:
    ld      a,[playerJumpForce]
    srl     a
    ld      [playerJumpForce],a
    ret


player_fall:

    ; check if we're falling at all
    ld      a,[playerFallSpeed]
    ld      d,a ; load the current fall speed as the loop counter
    cp      0
    ret     z

    ; if we're sliding only fall every couple of ticks
    ld      a,[playerWallSlideTick]
    and     PLAYER_SLIDE_SLOWDOWN
    cp      0
    ret     nz

.fall:

    ; check for downward collision
    call    player_collision_down
    jr      nz,.collision ; unlikely jump, thus jr and not jp

    ; reset ground state
    ld      a,0
    ld      [playerOnGround],a
    
    ; increase player position
    ld      a,[playerY]
    inc     a
    ld      [playerY],a
        
    ; loop until stored fall speed reaches 0
    dec     d
    jp      nz,.fall
    jp      .no_collision

.collision:

    ; reset player state to ground after collision
    ld      a,0
    ld      [playerFallSpeed],a

    ld      a,[playerOnGround]
    cp      1
    ret     z

    ; set ground flag
    ld      a,1
    ld      [playerOnGround],a

    ; check how long we've been falling
    ld      a,[playerFallFrames]
    cp      50
    jp      c,.done

    ; if we'be been falling for more than 30 frames play a landing animation
    ; and delay further movement
    ld      a,16
    ld      [playerLandingFrames],a

    ; set ground and play landing animation
    ld      a,PLAYER_ANIMATION_LANDING
    ld      [playerAnimation],a

.done:
    ld      a,0
    ld      [playerFallFrames],a
    ret

.no_collision:

    ; increase the number of frames we were falling
    ld      a,[playerFallFrames]
    cp      $ff
    ret     z ; fall frames max out at 255

    ; increase if not yet at 255
    inc     a
    ld      [playerFallFrames],a
    ret


player_increase_fall:

    ; if we're still jumping do not increase the fall speed
    ld      a,[playerJumpForce]
    cp      0
    ret     nz; do not incrase

    ; if we're in water do not increase the fall speed
    ld      a,[playerInWater]
    cp      0
    ret     nz

    ; otherwise increase it until we reach the maximum
    ld      a,[playerGravityMax]
    ld      b,a
    ld      a,[playerFallSpeed]
    cp      b
    ret     z

    inc     a
    ld      [playerFallSpeed],a
    ret


; Movement --------------------------------------------------------------------
player_accelerate:

    ld      a,[playerWallJumpTick]
    cp      0
    ret     nz

    ; if both directions are pressed at the same time ignore input
    ld      a,[coreInput]
    and     %00110000
    cp      %00110000
    ret     z

    ; check which direction is pressed
    ld      a,[coreInput]
    and     %00100000
    cp      %00100000
    jp      z,.acc_left

    ld      a,[coreInput]
    and     %00010000
    cp      %00010000
    jp      z,.acc_right

    ret ; not moving in any direction

.acc_right:
    ld      hl,playerSpeedRight

    ; set player direction
    ld      a,PLAYER_DIRECTION_RIGHT
    ld      [playerDirection],a
    jp      .accelerate

.acc_left:
    ld      hl,playerSpeedLeft

    ; set player direction
    ld      a,PLAYER_DIRECTION_LEFT
    ld      [playerDirection],a

.accelerate:
    ; load speed from corresponding direction variable 
    ld      a,[hl]
    cp      PLAYER_SPEED_MAX ; check if at max speed
    ret     z

    ; if not increase
    inc     a
    ld      [hl],a
    ret



player_decelerate:

    ; only decelerate on every 10th frame
    ; this introduces "lag" or a sliding when turning rapidly
    ld      a,[playerDecTick]
    inc     a
    cp      10
    jp      z,.decrease_right

    ; if not on 10th frame store frame count and return
    ld      [playerDecTick],a
    ret

.decrease_right:

    ; check if right direction is still pressed
    ld      a,[coreInput]
    and     %00010000
    jp      nz,.decrease_left

    ; right
    ld      a,[playerSpeedRight]
    cp      0
    jp      z,.decrease_left
    dec     a
    ld      [playerSpeedRight],a

.decrease_left:

    ; check if left direction is still pressed
    ld      a,[coreInput]
    and     %00100000
    jp      nz,.no_decrease

    ; left
    ld      a,[playerSpeedLeft]
    cp      0
    jp      z,.no_decrease ; if it reached zero we're done

    dec     a
    ld      [playerSpeedLeft],a

.no_decrease:
    ld      a,0
    ld      [playerDecTick],a
    ret


; Movement Logic --------------------------------------------------------------
player_move:

    ; check for landing frames
    ld      a,[playerLandingFrames]
    cp      0
    jp      nz,.landing

    ; reset wall flag
    ld      a,0
    ld      [playerDirectionWall],a

    ; are we moving at all?
    ld      a,[playerSpeedLeft]
    ld      b,a
    ld      a,[playerSpeedRight]
    add     a,b
    cp      0
    jp      z,.stopped

    ; set walking animation only when on ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.not_on_ground

    ld      a,PLAYER_ANIMATION_WALKING
    ld      [playerAnimation],a
    
.not_on_ground:

    ld      a,[playerInWater]
    cp      0
    jp      z,.not_in_water

    ld      a,PLAYER_ANIMATION_SWIMMING
    ld      [playerAnimation],a

    ; half speed when in water
    ld      a,[playerMoveTick]
    cp      1
    jp      nz,.delay
    ld      a,0
    ld      [playerMoveTick],a

.not_in_water:

    ; load x position
    ld      a,[playerX]
    ld      d,a

    ; move right -----------------------------------
.move_right:
    ld      a,[playerSpeedRight]
    cp      0
    jp      z,.move_left
    ld      e,a

.loop_right:

    call    player_collision_right
    jp      z,.not_blocked_right

    ; set wall flag
    ld      a,PLAYER_DIRECTION_RIGHT
    ld      [playerDirectionWall],a

    ; set pushing animation when not in water
    ld      a,[playerInWater]
    cp      0
    jp      z,.pushing_right
    jp      .idle_right

.pushing_right:
    call    player_collision_right_all
    jp      z,.idle_right
    ld      a,PLAYER_ANIMATION_PUSHING
    ld      [playerAnimation],a
    jp      .move_left

.idle_right:
    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    jp      .move_left

.not_blocked_right:
    inc     d
    ld      a,d
    ld      [playerX],a
    dec     e
    jp      nz,.loop_right


    ; move left ------------------------------------
.move_left:
    ld      a,[playerSpeedLeft]
    cp      0
    jp      z,.moved
    ld      e,a

.loop_left:

    call    player_collision_left
    jp      z,.not_blocked_left

    ; set wall flag
    ld      a,PLAYER_DIRECTION_LEFT
    ld      [playerDirectionWall],a

    ; set pushing animation when not in water
    ld      a,[playerInWater]
    cp      0
    jp      z,.pushing_left
    jp      .idle_left

.pushing_left:
    call    player_collision_left_all
    jp      z,.idle_left
    ld      a,PLAYER_ANIMATION_PUSHING
    ld      [playerAnimation],a
    jp      .moved

.idle_left:
    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    jp      .moved

.not_blocked_left:
    dec     d
    ld      a,d
    ld      [playerX],a
    dec     e
    jp      nz,.loop_left


    ; moved ----------------------------------------
.moved:
    ld      a,d
    ld      [playerX],a
    ret     z

.stopped: 

    ; reset to idle animation if on ground
    ld      a,[playerOnGround]
    cp      0
    jp      z,.stopped_water

    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    ret

.stopped_water:
    ld      a,[playerInWater]
    cp      0
    ret     z

    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    ret

.delay:
    inc     a
    ld      [playerMoveTick],a
    ret

.landing:
    dec     a
    ld      [playerLandingFrames],a
    cp      0
    ret     nz

    ld      a,PLAYER_ANIMATION_IDLE
    ld      [playerAnimation],a
    ret


; Wall Sliding / Jumping Logic ------------------------------------------------
player_slide_wall:

    ld      a,[playerLandingFrames]
    cp      0
    ret     nz

    ; check if wall jump was performed
    ld      a,[playerWallJumpTick]
    cp      0
    jp      nz,.wall_jump_speed
            
    
    ; check if on ground / in water
    ld      a,[playerOnGround]
    cp      1
    jp      z,.on_ground
    
    ; check if on ground
    ld      a,[playerInWater]
    cp      1
    jp      z,.on_ground

    ; check if falling
    ld      a,[playerFallSpeed]
    cp      1
    jp      c,.not_pressing_wall ; if fall speed is <= 1 do not slide

    ; check if pressing against a wall
    ld      a,[playerDirectionWall]
    cp      0
    jp      z,.not_pressing_wall 

    ; check if player is pressing joypad in wall direction
    ld      b,a
    ld      a,[playerDirection]
    cp      b
    jr      nz,.not_pressing_wall

.pressing_wall:
    ld      b,a ; store wall direction

    ; check if already sliding
    ld      a,[playerWallSlideTick]
    cp      0 ; check if not sliding
    jp      nz,.sliding

    ; if pressing against a wall and not sliding and 
    ; directionWall != slideDirection init slide
    ; only allow slide if dir = 0 or after wall jump
    ; in case of wall jump, still do not allow the same wall to be used again
    ld      a,[playerWallSlideDir]
    cp      b
    ret     z ; exit if same direction

    ; check if player fully touches the wall before initiating a slide
    ld      a,[playerDirection]
    cp      PLAYER_DIRECTION_RIGHT
    jp      z,.slide_right

.slide_left:
    call    player_collision_left_all
    ret     z
    call    player_slide_wall_init
    ret

.slide_right:
    call    player_collision_right_all
    ret     z
    call    player_slide_wall_init
    ret

.sliding:

    ; if sliding for more than X frames end slide
    cp      PLAYER_SLIDE_DURATION
    jp      z,.sliding_done

    ; otherwise continue sliding
    inc     a
    ld      [playerWallSlideTick],a

    ; set animation
    ld      a,PLAYER_ANIMATION_SLIDE
    ld      [playerAnimation],a
    ret


.sliding_done:

    call    player_slide_wall_stop
    ld      a,0
    ld      [playerWallSlideTick],a

    ld      a,PLAYER_WALL_JUMP_WINDOW
    ld      [playerWallJumpWindow],a
    ret


.not_pressing_wall:

    ; check wall jump window
    ld      a,[playerWallJumpWindow]
    cp      0
    jp      nz,.check_wall_jump

    ; if sliding and no longer pressing, end slide
    ld      a,[playerWallSlideTick]
    cp      0 
    ret     z ; if not sliding, do nothing

    ; otherwise stop the slide and set the correct direction
    call    player_slide_wall_stop

    ; we have X frames where a wall jump can be executed by pressind
    ; the joypad away from the last jump direction and pressing the jump
    ; button at the same time
    ld      a,PLAYER_WALL_JUMP_WINDOW
    ld      [playerWallJumpWindow],a
            
    ret


.on_ground:

    ; if we didnt slide we dont need to reset
    ld      a,[playerWallSlideDir]
    cp      0
    ret     z

    ; otherwise reset the sliding state and switch the direction
    call    player_slide_wall_stop
    ld      a,0
    ld      [playerWallSlideDir],a

    ret


.check_wall_jump:

    ; decrease window for wall jump
    ld      a,[playerWallJumpWindow]
    dec     a
    ld      [playerWallJumpWindow],a

    ; check last wall direction against player direction, must be different
    ld      a,[playerDirection]
    ld      b,a
    ld      a,[playerWallSlideDir]
    cp      b
    ret     z ; player must press joypad away from the wall he slided on, otherwise return

    ; check if button was hold down since the last jump, if so don't jump again
    ld      a,[playerWallJumpPressed]
    cp      1
    ret     z

    ; check if jump button got pressed
    ld      a,[coreInput]
    and     %00000001
    ret     z

    ; set up jump force and reset fall speed
    ld      a,PLAYER_JUMP_WALL
    ld      [playerJumpForce],a

    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

    ld      a,0
    ld      [playerFallFrames],a
    ld      [playerFallSpeed],a
    ld      [playerWallJumpWindow],a

    ; setup forced movement away from the wall
    ld      a,[playerWallSlideDir]
    ld      [playerWallJumpDir],a

    ld      a,PLAYER_WALL_JUMP_DURATION
    ld      [playerWallJumpTick],a

    ; set up jump button state
    ld      a,1
    ld      [playerWallJumpPressed],a

    ret


.wall_jump_speed:
    
    ; decrease ticks left for wall jump speed boost
    ld      a,[playerWallJumpTick]
    dec     a
    ld      [playerWallJumpTick],a
    cp      0
    jp      z,.stop

    ; modify player speed variable
    ld      a,[playerWallJumpDir]
    cp      PLAYER_DIRECTION_LEFT
    jp      z,.right

.left:
    ld      a,2
    ld      [playerSpeedLeft],a
    ld      a,0
    ld      [playerSpeedRight],a
    ret

.right:
    ld      a,2
    ld      [playerSpeedRight],a
    ld      a,0
    ld      [playerSpeedLeft],a
    ret

.stop:
    ld      a,0
    ld      [playerSpeedRight],a
    ld      [playerSpeedLeft],a
    ret


player_slide_wall_init:
    ld      a,[playerDirectionWall]
    ld      [playerWallSlideDir],a
    ld      a,20
    ld      [playerWallSlideTick],a
    ret


player_slide_wall_stop:

    ; avoid graphical glitches when switching animation and direction
    ld      a,PLAYER_ANIMATION_FALL
    ld      [playerAnimation],a

    ; reset tick
    ld      a,0
    ld      [playerWallSlideTick],a
    ld      [playerWallJumpWindow],a

    ; reset fall frames
    ld      [playerFallFrames],a

    ret



; Animation Updates -----------------------------------------------------------
player_animate:

    ; check for animation changes
    ld      a,[playerAnimationLast]
    ld      b,a
    ld      a,[playerAnimation]
    cp      b
    jp      z,.no_animation_change
    
    ; switch to new animation
    ld      b,a
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_set
    call    sprite_animation_start
    ld      a,b
    ld      [playerAnimationLast],a
    call    player_update_sprite_row

.no_animation_change:

    ; check for direction changes
    ld      a,[playerDirectionLast]
    ld      b,a
    ld      a,[playerDirection]
    cp      b
    jp      z,.no_direction_change

    ; switch to new direction
    cp      PLAYER_DIRECTION_RIGHT
    jp      z,.direction_right

.direction_left:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_unset_mirror
    jp      .direction_changed

.direction_right:
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_set_mirror
    jp      .direction_changed

.direction_changed:

    ; reset animation frame
    ld      a,PLAYER_SPRITE_INDEX
    call    sprite_animation_start

    ld      a,[playerDirection]
    ld      [playerDirectionLast],a

.no_direction_change:
    ret


; Player Pounding -------------------------------------------------------------
player_pound:

    ; check if already pounding
    ld      a,[playerIsPounding]
    cp      0
    jp      nz,.delay

    ; check if falling for at least 3 frames
    ld      a,[playerFallFrames]
    cp      3
    ret     c

    ; check for B button
    ld      a,[coreInput]
    and     %00000010
    cp      %00000010
    ret     nz

    ; check if under water or swimming
    ld      a,[playerUnderWater]
    cp      1
    ret     z

    ld      a,[playerInWater]
    cp      1
    ret     z

    ; set pounding and animation
    ld      a,1
    ld      [playerIsPounding],a

    ld      a,PLAYER_ANIMATION_POUND_START
    ld      [playerAnimation],a

    ld      a,PLAYER_POUND_DELAY_START
    ld      [playerPoundTick],a

    ; reset movement speed
    ld      a,0
    ld      [playerSpeedRight],a
    ld      [playerSpeedLeft],a
    ld      [playerFallSpeed],a
    ld      [playerWaterTick],a

    ; reset gravity tick
    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

    ; set new gravity max
    ld      a,PLAYER_GRAVITY_MAX_POUND
    ld      [playerGravityMax],a

    ret     
    
    ; delay the start / stop animation
.delay:
    
    ld      a,[playerPoundTick]
    cp      0
    jp      z,.pounding
    dec     a
    ld      [playerPoundTick],a

    ; disable gravity during delay
    ld      a,0
    ld      [playerFallSpeed],a
    ld      a,PLAYER_GRAVITY_INTERVAL
    ld      [playerGravityTick],a

    ret

.pounding:
    
    ld      a,[playerIsPounding]
    cp      2
    jp      z,.end

    ; set fall speed
    ld      a,PLAYER_GRAVITY_MAX_POUND
    ld      [playerFallSpeed],a

    ; check if we hit water
    ld      a,[playerInWater]
    cp      1
    jp      z,.water

    ; check if we hit ground
    ld      a,[playerOnGround]
    cp      1
    ret     nz; return if not

    ; TODO check for breakable blocks etc.

    ; If we hit ground shake screen, delay and then disable pounding
    ld      a,10
    call    screen_shake

    ld      a,PLAYER_POUND_DELAY_END
    ld      [playerPoundTick],a

    ld      a,PLAYER_ANIMATION_POUND_END
    ld      [playerAnimation],a

    ; no more falling
    ld      a,0
    ld      [playerFallSpeed],a

    ; switch to end mode
    ld      a,2
    ld      [playerIsPounding],a
    ret

.water:
    ld      a,[playerWaterTick]
    cp      25
    jp      nc,.water_end

    ; slow down after the first 5 frames
    cp      5
    jp      c,.water_next
    ld      a,1
    ld      [playerFallSpeed],a

.water_next:
    ld      a,[playerWaterTick]
    inc     a
    ld      [playerWaterTick],a
    ret

.water_end:

    ; skip water offset 
    ld      a,[playerUnderWater]
    cp      1
    jp      z,.under_water

    ld      a,PLAYER_WATER_OFFSET_MAX
    jp      .water_end_set

.under_water:
    ld      a,15
    jp      .water_end_set

.water_end_set:
    ld      [playerWaterTick],a

    ; switch to end mode
    ld      a,2
    ld      [playerIsPounding],a

    ld      a,PLAYER_POUND_DELAY_END
    ld      [playerPoundTick],a

    ld      a,PLAYER_ANIMATION_POUND_END
    ld      [playerAnimation],a

    ret

.end:
    
    ; unset pound
    ld      a,0
    ld      [playerIsPounding],a

    ; reset gravity max
    ld      a,PLAYER_GRAVITY_MAX
    ld      [playerGravityMax],a
    ret


; Sleep Timer -----------------------------------------------------------------
player_sleep:

    ; in case no button is pressed decrease the sleep ticker 
    ld      a,[coreInput]
    and     %00110011
    jp      nz,.active

    ; also check whether we're on the ground
    ld      a,[playerOnGround]
    cp      1
    jp      nz,.active

    ; check sleep ticker
    ld      a,[playerSleepTick]
    cp      0
    ret     nz

    ; set sleeping
    ld      a,PLAYER_ANIMATION_SLEEP
    ld      [playerAnimation],a
    ret

.active:
    ld      a,PLAYER_SLEEP_WAIT
    ld      [playerSleepTick],a
    ret


player_sleep_timer:
    ld      a,[playerSleepTick]
    cp      0
    ret     z

    dec     a
    ld      [playerSleepTick],a
    ret


; Animation Sprite Row Mapping ------------------------------------------------
playerAnimationRowMap:
    DB 0; IDLE      
    DB 1; WALKING   
    DB 3; SLEEP     
    DB 4; PUSHING   
    DB 2; JUMP      
    DB 2; FALL      
    DB 1; RUNNING   
    DB 6; SWIMMING  
    DB 7; DISSOLVE  
    DB 2; SURFACE   
    DB 0; SLIDE     
    DB 5; POUND START
    DB 5; POUND STOP
    DB 8; LANDING

player_update_sprite_row:

    push    hl
    push    de
    push    bc

    ; figure out which row in the sprite sheet maps
    ; to the current animation
    ld      a,[playerAnimation]
    ld      hl,playerAnimationRowMap
    ld      d,0
    ld      e,a
    add     hl,de
    ld      a,[hl]

    ; load the corresponding row into vram
    ld      hl,DataPlayerImg
    ld      b,0
    ld      c,a
    ld      de,$8000
    ld      a,PLAYER_SPRITE_ROWS * 2
    call    map_load_sprite_row

    pop     bc
    pop     de
    pop     hl

    ret

