SECTION "SaveLogic",ROM0

; Constants -------------------------------------------------------------------
SAVE_GAME_VERSION          EQU 2

SAVE_HEADER_SIZE           EQU 3
SAVE_VERSION_SIZE          EQU 1
SAVE_PLAYER_DATA_SIZE      EQU 10
SAVE_ENTITY_HEADER_SIZE    EQU 1
SAVE_ENTITY_DATA_SIZE      EQU ENTITY_STORED_STATE_SIZE
SAVE_COMPLETE_SIZE         EQU SAVE_HEADER_SIZE + SAVE_VERSION_SIZE + SAVE_PLAYER_DATA_SIZE + SAVE_ENTITY_HEADER_SIZE + SAVE_ENTITY_DATA_SIZE


; SRAM Handling Routines ------------------------------------------------------
save_load_from_sram:
    
    di

    ; writing $0A anywhere into the $0000-1FFFF range will enable external ram
    ld      hl,$0000 
    ld      [hl],$0A 

    ; calculate checksum
    ld      bc,SAVE_COMPLETE_SIZE
    ld      hl,$A001
    call    _save_calculate_checksum

    ; compare
    ld      b,a
    ld      hl,$A000 
    ld      a,[hli]
    cp      b
    jp      nz,.defaults

    ; check header
    ld      a,[hli]
    cp      $12
    jp      nz,.defaults

    ld      a,[hli]
    cp      $34
    jp      nz,.defaults

    ld      a,[hli]
    cp      $56
    jp      nz,.defaults

    ; version
    ld      a,[hli]
    cp      SAVE_GAME_VERSION
    jp      nz,.defaults

    ; ignore save state when start button is being pressed during powerup
    ld      a,[coreInput]
    and     %00001100
    cp      %00001100
    jp      z,.defaults

    ; Map Data
    ld      a,[hli]
    ld      [mapRoomX],a

    ld      a,[hli]
    ld      [mapRoomY],a

    ; Player Data
    ld      a,[hli]
    ld      [playerX],a

    ld      a,[hli]
    ld      [playerY],a

    ld      a,[hli]
    ld      [playerDirection],a

    ; Player Abilities
    ld      a,[hli]
    ld      [playerCanJump],a
    
    ld      a,[hli]
    ld      [playerCanWallJump],a

    ld      a,[hli]
    ld      [playerCanSwim],a

    ld      a,[hli]
    ld      [playerCanDive],a

    ld      a,[hli]
    ld      [playerCanPound],a

    ; stored entity state seperator
    ld      a,[hli] ; E5, "verified" via the checksum

    ; copy entity state to working ram
    ld      bc,SAVE_ENTITY_DATA_SIZE
    ld      de,entityStoredState
    call    core_mem_cpy

    jp      .load

.defaults:
    
    ld      a,24
    ld      [playerX],a

    ld      a,48
    ld      [playerY],a

    ld      a,2
    ld      [mapRoomX],a

    ld      a,0
    ld      [mapRoomY],a

.load:

    ld      a,[mapRoomX]
    ld      b,a
    ld      a,[mapRoomY]
    ld      c,a

    call    map_set_room
    call    player_reset

.end:
    ; disable external RAM
    ld      hl,$0000 
    ld      [hl],$00

    ei
    ret


save_store_to_sram:

    di

    ; save current screens entities
    ld      a,[mapRoomX]
    ld      [mapRoomLastX],a
    ld      b,a
    ld      a,[mapRoomY]
    ld      [mapRoomLastY],a
    call    entity_store

    ; writing $0A anywhere into the $0000-1FFFF range will enable external ram
    ld      hl,$0000 
    ld      [hl],$0A 

    ld      hl,$A000 
    
    ; checksum of the save data bytes starting from $A001
    ld      a,$00
    ld      [hli],a

    ; header prefix
    ld      a,$12
    ld      [hli],a

    ld      a,$34
    ld      [hli],a

    ld      a,$56
    ld      [hli],a

    ; game version
    ld      a,SAVE_GAME_VERSION
    ld      [hli],a

    ; Map Data
    ld      a,[mapRoomX]
    ld      [hli],a

    ld      a,[mapRoomY]
    ld      [hli],a

    ; Player Data
    ld      a,[playerX]
    ld      [hli],a

    ld      a,[playerY]
    ld      [hli],a

    ld      a,[playerDirection]
    ld      [hli],a

    ; Player Abilities
    ld      a,[playerCanJump]
    ld      [hli],a

    ld      a,[playerCanWallJump]
    ld      [hli],a

    ld      a,[playerCanSwim]
    ld      [hli],a

    ld      a,[playerCanDive]
    ld      [hli],a

    ld      a,[playerCanPound]
    ld      [hli],a

    ; Entity Data
    ld      a,$E5
    ld      [hli],a
    
    ; copy entity state to sram
    ld      bc,SAVE_ENTITY_DATA_SIZE
    ld      d,h
    ld      e,l
    ld      hl,entityStoredState
    call    core_mem_cpy

    ; caclulate checksum
    ld      bc,SAVE_COMPLETE_SIZE
    ld      hl,$A001
    call    _save_calculate_checksum

    ; write checksum byte
    ld      hl,$A000 
    ld      [hl],a

    ; disable external RAM
    ld      hl,$0000 
    ld      [hl],$00

    ei
    ret


; Helpers ---------------------------------------------------------------------
_save_calculate_checksum: ; hl = source address, bc = bytecount checksum byte -> a
    push    de

    ; must be in external RAM mode
    ld      d,0; checksum data

.loop:

    ld      a,[hli]
    add     d
    ld      d,a

    ; check if we're done
    dec	    c
	jr	    nz,.loop
	dec	    b
	jr	    nz,.loop

    ld      a,d; store out

    pop     de

    ret

