title_init:
    ld      a,80
    ld      [titleWaitCounter],a
    ld      a,GAME_MODE_INIT
    ld      [gameMode],a
    ret

title_update:
    ld      a,[gameMode]
    cp      GAME_MODE_TITLE
    jp      z,.title

    cp      GAME_MODE_INIT
    jp      z,.init

    cp      GAME_MODE_LOGO
    jp      z,.logo

    cp      GAME_MODE_FADE_IN
    jp      z,.fade_in

    cp      GAME_MODE_CONTINUE
    jp      z,.continue

    cp      GAME_MODE_START
    jp      z,.start

    ret

    ; Setup logo and fade in
.init:

    ; delay
    ld      a,[titleWaitCounter]
    dec     a
    ld      [titleWaitCounter],a
    cp      0
    ret     nz

    call    title_draw_logo

    ; setup fade in
    ld      a,GAME_MODE_LOGO
    ld      [gameMode],a
    call    screen_fade_in_light

    ; show the logo for 80 frames
    ld      a,80
    ld      [titleWaitCounter],a

    ld      a,SOUND_GAME_LOGO
    call    sound_play

    ret

; Show logo and fade out
.logo:

    ld      a,[screenFadeMode]
    cp      0
    ret     nz

    ; delay
    ld      a,[titleWaitCounter]
    dec     a
    ld      [titleWaitCounter],a
    cp      0
    ret     nz

    call    screen_fade_out_light
    ld      a,GAME_MODE_FADE_IN
    ld      [gameMode],a

    ld      a,4
    ld      [titleWaitCounter],a

    ret

; Setup title screen and fade in
.fade_in:

    ld      a,[screenFadeMode]
    cp      0
    ret     nz

    call    title_draw_room

    ; player
    ld      a,87
    ld      [playerX],a
    ld      a,96
    ld      [playerY],a

    ; delay
    ld      a,[titleWaitCounter]
    dec     a
    ld      [titleWaitCounter],a
    cp      0
    ret     nz

    ; fade over
    call    screen_fade_in_light
    ld      a,GAME_MODE_TITLE
    ld      [gameMode],a

    ret

; Title screen logic
.title:
    
    ; fake inputs to control player
    ld      a,[coreInputOn]
    and     %00001100
    ld      [coreInputOn],a

    ld      a,[coreInputOff]
    and     %00001100
    ld      [coreInputOff],a
    
    call    title_screen_movement

    ; Fake input for player update
    call    player_update
    call    sprite_animate_all
    call    sound_update

    ; Wait for start button press
    ld      a,[coreInputOn]
    and     BUTTON_START
    cp      BUTTON_START
    ret     nz

    ld      a,10
    ld      [titleWaitCounter],a

    ld      a,GAME_MODE_CONTINUE
    ld      [gameMode],a

    call    screen_fade_out_light

    ret

; Fade out and continue a existing game
.continue:
    ld      a,[screenFadeMode]
    cp      0
    ret     nz

    ; delay
    ld      a,[titleWaitCounter]
    dec     a
    ld      [titleWaitCounter],a
    cp      0
    ret     nz

    call    game_continue
    call    screen_fade_in_light

    ret

; Fade out and start a new game
.start:
    ld      a,[screenFadeMode]
    cp      0
    ret     nz

    ; delay
    ld      a,[titleWaitCounter]
    dec     a
    ld      [titleWaitCounter],a
    cp      0
    ret     nz

    call    game_start
    call    screen_fade_in_light
    ret



title_screen_movement:

    ; clean up actual input state
    ld      a,[coreInput]
    and     BUTTON_START | BUTTON_SELECT
    ld      c,a

    ; check if we need a new player movement command
    ld      a,[titlePlayerTick]
    cp      0
    jp      nz,.move

    ; new length of the movement
    call    math_random
    and     %00001111; at most 15 random frames
    add     10; minimum of 10 frames
    ld      [titlePlayerTick],a

    ; get new direction
    call    math_random
    and     %000001111
    ld      [titlePlayerDir],a

; continously move into the current target direction
.move:
    ld      a,[titlePlayerTick]
    dec     a
    ld      [titlePlayerTick],a

    ld      a,[titlePlayerDir]
    cp      0
    jp      z,.left

    cp      3
    jp      z,.right

    jp      .control

.left:

    ; don't leave the screen
    ld      a,[playerX]
    cp      16
    jp      c, .switch_to_right; x < 8

    ld      a,c
    or      BUTTON_LEFT
    ld      c,a
    jp      .control

.switch_to_right:
    ld      a,3
    ld      [titlePlayerDir],a
    jp      .right

.right:

    ; don't leave the screen
    ld      a,[playerX]
    cp      152
    jp      nc, .switch_to_left; x > 152

    ld      a,c
    or      BUTTON_RIGHT
    ld      c,a
    jp      .control

.switch_to_left:
    ld      a,0
    ld      [titlePlayerDir],a
    jp      .left

.control:
    ld      a,c
    ld      [coreInput],a

    ret


title_draw_logo:

    ; load title screen graphics into vram
    ld      de,DataLogoImg
    ld      hl,$8800; start target for decode write
    ld      bc,$8800 + 768; end target for decode write
    call    lz4_decode_block

    ; clear screen buffer
    ld      a,$00
    sub     128
    ld      hl,$9800
    ld      bc,512
    call    core_vram_set

    ; initial screen offset
    ld      hl,$9800 + 128
    ld      de,DataLogoLayout

    ; copy logo data into vram
    ld      b,8; 8 rows

.loop_y:
    ld      c,8; 8 bytes per row
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl


.loop_x:

    ; wait for vblank
    ld      a,[rSTAT]       ; <---+
    and     STATF_BUSY      ;     |
    jr      nz,@-4          ; ----+

    ld      a,[de]
    sub     128
    ld      [hl],a
    inc     de
    inc     hl

    ; loop
    dec     c
    jp      nz,.loop_x

    ; next line
    push    bc
    ld      bc,18
    add     hl,bc
    pop     bc

    dec     b
    jp      nz,.loop_y

    ret


title_draw_room:

    ; clear screen buffer
    ld      a,$00
    sub     128
    ld      hl,$9800
    ld      bc,512
    call    core_vram_set

    ; setup title screen room graphics
    ld      de,DataTileImg
    call    map_load_tileset

    ; load additional text graphics
    ld      de,DataTitleImg
    ld      hl,$9100; start target for decode write
    ld      bc,$9200; end target for decode write
    call    lz4_decode_block

    ; draw room
    ld      b,15
    ld      c,15
    call    map_set_room

    ; draw the room right away instead of waiting for the next vblank to draw it
    call    map_load_room

    ; setup title text
    ld      hl,DataTitleLayout
    ld      de,$9800 + 488; "Start"
    ld      bc,$04
    call    core_vram_cpy

    ; TODO check for existing save data before displaying the continue option
    ld      hl,DataTitleLayout + 4
    ld      de,$9800 + 519; "Continue"
    ld      bc,$06
    call    core_vram_cpy

    ret

