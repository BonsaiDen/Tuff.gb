; Initialization --------------------------------------------------------------
game_init:

    ; setup background tile palette
    ld      a,%11100100
    ld      [rBGP],a; load a into the memory pointed to by rBGP

    ; set object palette 0
    ld      a,%11010000 
    ld      [rOBP0],a 

    ; reset fading
    ld      a,0
    ld      [gameFadeMode],a

    ; load char data
    ld      hl,DataCharImg
    ld      de,$8000
    ld      bc,2048     ; length (8 bytes per tile) x (256 tiles)
    call    mem_Copy    ; Copy tile data to memory

    ; load tile data
    ld      hl,DataTileImg
    ld      de,$8800
    ld      bc,4096     ; length (8 bytes per tile) x (256 tiles)
    call    mem_Copy    ; Copy tile data to memory

    ; Player
    call    player_init

    ; Map
    ld      b,2
    ld      c,0
    call    map_set_room



    ld      hl,$FF25
    ld      [hl],%11111111 ; output all channels to both speakers
    inc     hl
    ld      [hl],%00000000 ; dis-able sound

    ;ld      hl,$FF10

    ;;          -SSSOIII / sweep register
    ;ld      a,%00000000
    ;ld      [hli],a

    ;;          WWLLLLLL / length wave pattern duty
    ;ld      a,%10111111
    ;ld      [hli],a

    ;;          VVVVENNN
    ;ld      a,%01110001
    ;ld      [hli],a

    ;;          FFFFFFFF frequency lower 8 bits
    ;ld      a,%00000010
    ;ld      [hli],a
    ;
    ;;          IS000FFF frequency lower 8 bits
    ;ld      a,%10000000
    ;ld      [hli],a


    ; noise
    ;ld      hl,$FF20
    ;ld      [hl],%00000001
    ;inc     hl

    ;;             VVVVESSS
    ;ld      [hl],%01000001 ; fade out
    ;inc     hl

    ;;             FFFFSDDD
    ;ld      [hl],%01101011 ; polynomial counter, higher value > lower noise (darker), noise freq, 1 = 7 steps, sounds glichted, 0 = 15 = normal noise
    ;inc     hl
    ;;             IE
    ;ld      [hl],%10000000 ; start intiially, play it endlessly


    ret


; Main Loop -------------------------------------------------------------------
game_loop_half:
    call    player_update
    ret

game_loop:
    call    sprite_animate_all

    ld      a,[inputState]
    and     %00000010
    jp      z,.not_fade_out
    call    game_fade_out

.not_fade_out:

    ld      a,[inputState]
    and     %00000100
    jp      z,.not_fade_in
    call    game_fade_in

.not_fade_in:

    ret


; Screen Fading ---------------------------------------------------------------
gameBGFadeMask:
    DB      %11100100
    DB      %11100101
    DB      %11101010
    DB      %11111111


gameSpriteFadeMask:
    DB      %11010000 
    DB      %11100100 
    DB      %11101000 
    DB      %11111100 


game_fade_out:
    ld      a,1
    ld      [gameFadeMode],a
    ld      a,0
    ld      [gameFadeIndex],a
    ret


game_fade_in:
    ld      a,2
    ld      [gameFadeMode],a
    ld      a,3
    ld      [gameFadeIndex],a
    ret


game_fade_timer:

    ; check if fading
    ld      a,[gameFadeMode]
    cp      0
    ret     z

    ; fade index
    ld      a,[gameFadeIndex]
    ld      b,0
    ld      c,a
    
    ; bg mask
    ld      hl,gameBGFadeMask
    add     hl,bc
    ld      a,[hl]
    ld      [rBGP],a

    ; sprite mask
    ld      hl,gameSpriteFadeMask
    add     hl,bc
    ld      a,[hl]
    ld      [rOBP0],a

    ; fade mode
    ld      a,[gameFadeMode]
    cp      2
    jp      z,.fade_in
        
    ; fade out
    ld      a,[gameFadeIndex]
    cp      3
    jp      z,.done
    inc     a
    ld      [gameFadeIndex],a
    jp      .done

    ; fade in
.fade_in:
    ld      a,[gameFadeIndex]
    cp      0
    jp      z,.done
    dec     a
    ld      [gameFadeIndex],a

.done:
    ret


animate_tiles:


    ; check if there are any tile animations
    ld      a,TILE_ANIMATION_COUNT
    cp      0
    ret     z

    ; store state
    push    hl
    push    de
    push    bc

    ; loop and animate tiles
    ld      d,0
    ld      hl,tileAnimationIndexes
.animate:

    ; update current tile animation index
    ld      a,[hl]
    inc     a
    and     %00000011 ; modulo 4
    ld      [hl],a

    ; update vram  (hl = source, de = dest, bc = size (16))
    push    hl
    push    de

    ; store animation index
    ld      e,a 

    ; get base tile value of the animation (base + d * 4)
    ld      hl,DataTileAnimation
    ld      b,0
    ld      c,d
    sla     c
    sla     c
    add     hl,bc
    ld      a,[hl] 
    ld      d,a ; base tile value $00 - $ff

    ; get the current tile value of the animation (base + d * 4 + a)
    ld      c,e 
    add     hl,bc
    ld      a,[hl] ; current tile value $00 - $ff

    ; get the target address in vram (multiply the base tile by 16 + $8800)
    ld      h,0
    ld      l,d
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl
    ld      bc,$8800
    add     hl,bc
    ld      d,h
    ld      e,l

    ; get the current animation address (multiply the current tile by 16 + DataTileImg)
    ld      h,0
    ld      l,a
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl
    ld      bc,DataTileImg
    add     hl,bc

    ; set the length
    ld      b,0
    ld      c,16
    call    mem_CopyVRAM

    pop     de
    pop     hl
    ; end of vram update

    ; next animation
    inc     hl
    inc     d
    ld      a,d
    cp      TILE_ANIMATION_COUNT
    jp      nz,.animate
    ; end of loop

    ; restore state
    pop     bc
    pop     de
    pop     hl

    ret


; 200ms Timer -----------------------------------------------------------------
game_timer_200:
    call    animate_tiles
    ret


; 125ms Timer -----------------------------------------------------------------
game_timer_125
    call    player_timer_125
    call    game_fade_timer
    ret

