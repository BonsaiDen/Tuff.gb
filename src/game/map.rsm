; Map -------------------------------------------------------------------------
; The map is always 25x32 rooms
; each room has 10x8 (16x16px) tiles for a total of 80 tiles per room
; map data is aligned in room offsets
map_set_room: ; a = x, b = y

    push    hl

    ; offset = (y * width + x) * 80

    ld      hl,DataMapMain + 80
    ld      a,h
    ld      [mapRoomDataOffsetTopD],a
    ld      a,l
    ld      [mapRoomDataOffsetTopE],a

    pop     hl

    ret


; Core Map Draw Routine -------------------------------------------------------
map_draw_room:

    ; row counter
    ld      b,0
    
    ; col counter
    ld      c,0

    ; screen pointer base offset
    ld      hl,$9800

    ; map room pointer
    ld      a,[mapRoomDataOffsetTopD]
    ld      d,a
    ld      a,[mapRoomDataOffsetTopE]
    ld      e,a

    ; inc     de only increase on every second row and every second tile

.loopy:

    ; < 16
    ld      a,b
    cp      16 ; 16 / 2 = 8 tiles
    jp      z,.done
    ld      c,0

    ; store map data pointer for the start of the row
    push    de

.loopx:
    
    ld      a,[de]

    ; set tile
    call    get_tile_value
    sub     a,128
    ld      [hl],a

    ; on every uneven column move the map pointer offset forward by 1
    ld      a,c
    and     $01
    jp      z,.skip
    inc     de

.skip:

    ; x++
    inc     c 

    ; next screen offset
    inc     hl

    ; x < 20
    ld      a,20
    cp      c
    jp      nz,.loopx
    inc     b; y++

    ; skip the rest of the screen buffer
    ld      d,0
    ld      e,12
    add     hl,de

    ; restore map pointer offset
    pop     de 

    ; on uneven row move the map block pointer offset forward by 10
    ld      a,b
    and     $01
    jp      nz,.loopy

    ; increase pointer by 10
    push    hl

    ld      h,d
    ld      l,e

    ld      d,0 
    ld      e,10

    add     hl,de

    ld      d,h
    ld      e,l

    pop     hl

    jp      .loopy

.done:
    ret


get_tile_value: ; a = block value -> a tile value

    push    hl

    ld      l,a; store block value

    ; calculate the sub tile index into the block def data
    ; this is done via even/ueven rows and tiles
    ; and is later be used as the highbyte of the index into the blockdef
    ; data table (very clever indeed)
    ld      a,b ; y
    and     $01; is now 1 or 0
    add     a,a; 2 or 0
    ld      h,a; h now has the y offset

    ld      a,c
    and     $01 ; 1 or 2
    add     a,h
    
    ; BlockDef data is specifically offset at $2000 in ROM0
    add     a,$20
    ld      h,a
    ld      a,[hl] ; load the actual tile value

    pop     hl

    ret


get_col_at_screen: ; b = x coordinate, c = ycoordinate (both without scroll offsets) -> b collision value

    push    hl

    ; divide x by 8
    srl     b
    srl     b
    srl     b

    ; divide y by 8
    srl     c 
    srl     c
    srl     c

    ; index into screen data at b * 32 + a
    ld      h,0 
    ld      l,c 

    ; multiply by 32 
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl

    ld      b,$98
    ld      c,b
    add     hl,bc

    ; load tile value from background buffer
    ld      a,[hl]

    ; load collision value from table
    ld      h,$24
    ld      l,a
    ld      a,[hl]

    pop     hl

    ret

