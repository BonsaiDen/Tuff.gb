; Map -------------------------------------------------------------------------
; The map is always 25x32 rooms
; each room has 10x8 (16x16px) tiles for a total of 80 tiles per room
; map data is aligned in room offsets
map_set_room: ; a = x, b = y

    push    hl

    ; offset = (y * width + x) * 80

    ld      hl,DataMapMain 
    ld      a,h
    ld      [mapRoomDataOffsetTopD],a
    ld      a,l
    ld      [mapRoomDataOffsetTopE],a

    pop     hl

    ret


; Core Map Draw Routine -------------------------------------------------------
map_draw_room:

    ; row counter
    ld      b,8
    
    ; col counter
    ld      c,0

    ; screen pointer base offset
    ld      hl,$9800

    ; map room pointer
    ld      a,[mapRoomDataOffsetTopD]
    ld      d,a
    ld      a,[mapRoomDataOffsetTopE]
    ld      e,a

    ; reset RLE
    ld      a,0
    ld      [mapRLERepeat],a

.loop_y:

    ; y loop header
    ld      a,b
    cp      0
    jp      z,.done
    dec     b

    ; y loop body
    ld      c,10

.loop_x:

    dec     c

    ; check if we need to repeat any more blocks
    ld      a,[mapRLERepeat]
    cp      0
    jp      nz,.draw_rle ; if so, just draw another block

    ; otherwise fetch the next block
    ld      a,[de] ; 
    cp      250 ; check for rle length indicator (blockValue > 249)
    jp      c,.no_rle ; 

    ; yes we got RLE data, store the number of repeats
    sub     246
    ld      [mapRLERepeat],a;

    ; load the real block value
    inc     de
    ld      a,[de]
    ld      [mapRLEValue],a
    ; fall through

    ; no, just a normal block
.no_rle:
    inc     de; next block 
    jp      .draw_block

.draw_rle:
    dec     a; a is still mapRLERepeat
    ld      [mapRLEValue],a
    ld      a,[mapRLEValue]

.draw_block:

    ; TODO get the actual tile value
    ;call    get_tile_value

    ; draw 4 tiles
    push    hl
    push    de
    push    bc

    ; drawing ------------------------------------------

    ld      d,a ; save block data

    ; upper left
    ld      b,$20 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    ld      [hl],a ;  draw + 0


    ; upper right
    ld      b,$21 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    inc     hl
    ld      [hl],a ; draw +1


    ; skip one rwo
    ld      a,d ; save block
    ld      d,0
    ld      e,31
    add     hl,de
    ld      d,a ; restore block

    ; lower left
    ld      b,$22 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    ld      [hl],a ; draw + 32

    ; lower right
    ld      b,$23 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    inc     hl
    ld      [hl],a ; draw + 33

    ; drawing ------------------------------------------
    pop     bc
    pop     de
    pop     hl

    ; next x block
    inc     hl
    inc     hl

    ; x loop end
    ld      a,c
    cp      0
    jp      nz,.loop_x

    ; y loop end (skip one 16x16 screen data row)
    push    de
    ld      d,0
    ld      e,44 ; 12 left + one full row of 32
    add     hl,de
    pop     de

    jp      .loop_y


.done:
    ret




map_draw_old:

    ; row counter
    ld      b,0
    
    ; col counter
    ld      c,0

    ; screen pointer base offset
    ld      hl,$9800

    ; map room pointer
    ld      a,[mapRoomDataOffsetTopD]
    ld      d,a
    ld      a,[mapRoomDataOffsetTopE]
    ld      e,a

    ; inc     de only increase on every second row and every second tile

.loopy:

    ; < 16
    ld      a,b
    cp      16 ; 16 / 2 = 8 tiles
    jp      z,.done
    ld      c,0

    ; store map data pointer for the start of the row
    push    de

.loopx:
    
    ld      a,[de]

    ; set tile
    call    get_tile_value
    sub     a,128
    ld      [hl],a

    ; on every uneven column move the map pointer offset forward by 1
    ld      a,c
    and     $01
    jp      z,.skip
    inc     de

.skip:

    ; x++
    inc     c 

    ; next screen offset
    inc     hl

    ; x < 20
    ld      a,20
    cp      c
    jp      nz,.loopx
    inc     b; y++

    ; skip the rest of the screen buffer
    ld      d,0
    ld      e,12
    add     hl,de

    ; restore map pointer offset
    pop     de 

    ; on uneven row move the map block pointer offset forward by 10
    ld      a,b
    and     $01
    jp      nz,.loopy

    ; increase pointer by 10
    push    hl

    ld      h,d
    ld      l,e

    ld      d,0 
    ld      e,10

    add     hl,de

    ld      d,h
    ld      e,l

    pop     hl

    jp      .loopy

.done:
    ret


get_tile_value: ; a = block value -> a tile value

    push    hl

    ld      l,a; store block value

    ; calculate the sub tile index into the block def data
    ; this is done via even/ueven rows and tiles
    ; and is later be used as the highbyte of the index into the blockdef
    ; data table (very clever indeed)
    ld      a,b ; y
    and     $01; is now 1 or 0
    add     a,a; 2 or 0
    ld      h,a; h now has the y offset

    ld      a,c
    and     $01 ; 1 or 2
    add     a,h
    
    ; BlockDef data is specifically offset at $2000 in ROM0
    add     a,$20
    ld      h,a
    ld      a,[hl] ; load the actual tile value

    pop     hl

    ret


get_col_at_screen: ; b = x coordinate, c = ycoordinate (both without scroll offsets) -> b collision value

    push    hl

    ; divide x by 8
    srl     b
    srl     b
    srl     b

    ; divide y by 8
    srl     c 
    srl     c
    srl     c

    ; index into screen data at b * 32 + a
    ld      h,0 
    ld      l,c 

    ; multiply by 32 
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl

    ld      b,$98
    ld      c,b
    add     hl,bc

    ; load tile value from background buffer
    ld      a,[hl]

    ; load collision value from table
    ld      h,$24
    ld      l,a
    ld      a,[hl]

    pop     hl

    ret

