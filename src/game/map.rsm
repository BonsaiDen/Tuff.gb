; Constants -------------------------------------------------------------------
MAP_INDEX_SIZE      EQU     512
MAP_RLE_VALUE       EQU     249
                            


; Map -------------------------------------------------------------------------
; The map is always 25x32 rooms
; each room has 10x8 (16x16px) tiles for a total of 80 tiles per room
; map data is aligned in room offsets
map_set_room: ; b = x, c = y

    push    hl
    push    de

    ; store new room coordinates
    ld      a,b
    ld      [mapRoomX],a
    ld      a,c
    ld      [mapRoomY],a

    ; RoomId = y * MAP_WIDTH + x
    ; RoomOffset = [MapOffset + RoomID * 2][0] and [1]
    ; MapData = (MapOffset + MapIndexSize + RoomOffset) - 1

    ; Offset into Index ------------------------

    ; y * MAP_WIDTH
    ld      h,16
    ld      e,c
    call    math_mul8b ; hl = offset into index

    ; + x
    ld      c,b
    ld      b,0
    add     hl,bc

    ; * 2
    add     hl,hl

    ; + MapOffset
    ld      bc,DataMapMain
    add     hl,bc

    ; Room Offset Value ------------------------
    ld      a,[hli]
    ld      b,a

    ld      a,[hl]
    ld      c,a

    ; MapOffset Room Offset 
    ld      hl,DataMapMain
    add     hl,bc

    ; + MapIndexSize - 1
    ld      bc,MAP_INDEX_SIZE - 1
    add     hl,bc


    ; store it
    ld      a,h
    ld      [mapRoomDataOffsetTopD],a
    ld      a,l
    ld      [mapRoomDataOffsetTopE],a

    pop     de
    pop     hl

    ; draw the room
    call    map_draw_room

    ret


; Scrolling -------------------------------------------------------------------
map_scroll_left:
    ld      a,[mapRoomX]
    dec     a
    ld      b,a
    ld      a,[mapRoomY]
    ld      c,a
    call    map_set_room
    ret


map_scroll_right:
    ld      a,[mapRoomX]
    inc     a
    ld      b,a
    ld      a,[mapRoomY]
    ld      c,a
    call    map_set_room
    ret


map_scroll_down:
    ld      a,[mapRoomX]
    ld      b,a
    ld      a,[mapRoomY]
    inc     a
    ld      c,a
    call    map_set_room
    ret


map_scroll_up:
    ld      a,[mapRoomX]
    ld      b,a
    ld      a,[mapRoomY]
    dec     a
    ld      c,a
    call    map_set_room
    ret


; Core Map Draw Routine -------------------------------------------------------
map_draw_room:

    ; row counter
    ld      b,8
    
    ; col counter
    ld      c,0

    ; screen pointer base offset
    ld      hl,mapRoomBuffer

    ; map room pointer
    ld      a,[mapRoomDataOffsetTopD]
    ld      d,a
    ld      a,[mapRoomDataOffsetTopE]
    ld      e,a

    ; reset RLE
    ld      a,0
    ld      [mapRLERepeat],a

.loop_y:

    ; y loop header
    ld      a,b
    cp      0
    jp      z,.done
    dec     b

    ; y loop body
    ld      c,10

.loop_x:

    dec     c ; reduce column counter

    ; RLE ----------------------------------------
    
    ; check if we need to repeat any more blocks
    ld      a,[mapRLERepeat]
    cp      0
    jp      nz,.draw_rle ; if so, just draw another block

    ; otherwise fetch the next block
    inc     de; 
    ld      a,[de]

    ; check if it is RLE data
    cp      MAP_RLE_VALUE
    jp      z,.rle
    cp      MAP_RLE_VALUE + 1 ; check for rle length indicator (blockValue > 249)
    jp      c,.draw_block

.rle:

    ; yes we got RLE data, store the number of repeats;
    ; 249 means draw the following tile value 3 times
    sub     MAP_RLE_VALUE - 2
    ld      [mapRLERepeat],a;

    ; load the real block value
    inc     de
    ld      a,[de]
    ld      [mapRLEValue],a
    jp      .draw_block

.draw_rle:
    dec     a
    ld      [mapRLERepeat],a
    ld      a,[mapRLEValue]

    ; RLE ----------------------------------------

.draw_block:

    ; draw 4 8x8 tiles
    push    hl
    push    de
    push    bc

    ; drawing ------------------------------------------

    ld      d,a ; save block data

    ; upper left
    ld      b,$20 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    ld      [hli],a ;  draw + 0


    ; upper right
    ld      b,$21 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    ld      [hl],a ; draw +1

    ; skip one screen buffer row
    ld      a,d ; save block
    ld      d,0
    ld      e,31
    add     hl,de
    ld      d,a ; restore block

    ; lower left
    ld      b,$22 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    ld      [hli],a ; draw + 32

    ; lower right
    ld      b,$23 ; block def row 0 offset
    ld      c,d
    ld      a,[bc] ; tile value
    sub     a,128 ; tile data offset
    ld      [hl],a ; draw + 33

    ; drawing ------------------------------------------
    pop     bc
    pop     de
    pop     hl

    ; next x block
    inc     hl
    inc     hl

    ; x loop end
    ld      a,c
    cp      0
    jp      nz,.loop_x

    ; y loop end (skip one 16x16 screen data row)
    push    de
    ld      d,0
    ld      e,44 ; 12 left + one full row of 32
    add     hl,de
    pop     de

    jp      .loop_y


.done:

    ; Copy to VRAM
    ld       hl,mapRoomBuffer
    ld       de,$9800
    ld       bc,512
    call     mem_CopyVRAM
    ret


; Collision Detection ---------------------------------------------------------
map_get_collision: ; b = x pos, c = y pos (both without scroll offsets) -> z if no collision, nz if collision

    push    hl

    ; divide x by 8
    srl     b
    srl     b
    srl     b
    ld      a,b ; store x

    ; divide y by 8
    srl     c
    srl     c
    srl     c

    ; y * 32
    ld      h,0 
    ld      l,c

    add     hl,hl ; 2
    add     hl,hl ; 4
    add     hl,hl ; 8
    add     hl,hl ; 16
    add     hl,hl ; 32

    ; + mapRoomBuffer + x
    ld      b,$C3
    ld      c,a ; restore x
    add     hl,bc

    ; load tile value from background buffer
    ld      a,[hl]
    pop     hl

    ; ingore offscreen areas with unset tiles
    cp      255
    jp      z,.no_collision

    ; get the actual tile value and check if it is smalle than 64
    sub     128
    cp      64 ; tile value < 64 (the first 64 tiles are blocking) (c is set when value is greater a)
    jp      nc,.no_collision ; if not, there is no collision

.collision:
    or      1 ; set nz
    ret

.no_collision:
    ; TODO check for instant kill tiles and water
    cp      a ; set z
    ret


; Animation -------------------------------------------------------------------
map_animate_tiles:

    ld      a,[mapAnimationTick]
    cp      1
    jp      nz,.next

    ; check if there are any tile animations
    ld      a,TILE_ANIMATION_COUNT
    cp      0
    ret     z

    ; store state
    push    hl
    push    de
    push    bc

    ; loop and animate tiles
    ld      d,0
    ld      hl,mapAnimationIndexes
.animate:

    ; update current tile animation index
    ld      a,[hl]
    inc     a
    and     %00000011 ; modulo 4
    ld      [hl],a

    ; update vram  (hl = source, de = dest, bc = size (16))
    push    hl
    push    de

    ; store animation index
    ld      e,a 

    ; get base tile value of the animation (base + d * 4)
    ld      hl,DataTileAnimation
    ld      b,0
    ld      c,d
    sla     c
    sla     c
    add     hl,bc
    ld      a,[hl] 
    ld      d,a ; base tile value $00 - $ff

    ; get the current tile value of the animation (base + d * 4 + a)
    ld      c,e 
    add     hl,bc
    ld      a,[hl] ; current tile value $00 - $ff

    ; get the target address in vram (multiply the base tile by 16 + $8800)
    ld      h,0
    ld      l,d
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl
    ld      bc,$8800
    add     hl,bc
    ld      d,h
    ld      e,l

    ; get the current animation address (multiply the current tile by 16 + DataTileImg)
    ld      h,0
    ld      l,a
    add     hl,hl
    add     hl,hl
    add     hl,hl
    add     hl,hl
    ld      bc,DataTileImg
    add     hl,bc

    ; set the length
    ld      b,0
    ld      c,16
    call    mem_CopyVRAM

    pop     de
    pop     hl
    ; end of vram update

    ; next animation
    inc     hl
    inc     d
    ld      a,d
    cp      TILE_ANIMATION_COUNT
    jp      nz,.animate
    ; end of loop

    ; restore state
    pop     bc
    pop     de
    pop     hl

.next:
    ld      a,[mapAnimationTick]
    inc     a
    and     %00000001 ; modulo 1
    ld      [mapAnimationTick],a
    ret

