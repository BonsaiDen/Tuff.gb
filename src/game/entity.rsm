SECTION "EntityLogic",ROM0

; Load the entity state from RAM or the map default and  ----------------------
; Set up sprite and initial data based on type handler ------------------------
entity_load:

    ; clear tile row mapping
    call    _entity_reset_tile_row_mapping

    ; calculate offset into stored state buffer (based on CURRENT room)
    ld      a,[mapRoomY]
    ld      b,a
    ld      a,[mapRoomX]
    call    _entity_store_offset; returns the address for the entity in DE

    ; get offset for entity map data
    ld      hl,mapRoomUnpackBuffer + MAP_ROOM_SIZE
    ld      b,0

.entity_load_loop:
    push    de ; store entity stored state pointer

    ; get type / used
    ld      a,[hl]
    ld      c,a ; store byte
    and     %00111111 ; mask type bits
    cp      0
    jp      z,.entity_load_next ; entity is not set for room

    ; init base state
    push    hl
    call    _entity_screen_offset_hl

    ; set type
    ld      a,c
    and     %00111111 ; mask type bits
    ld      [hli],a

    ; reset flags
    ld      a,0
    ld      [hli],a

    ; set direction 
    ld      a,c
    and     %11000000 ; mask type bits
    srl     a
    srl     a
    srl     a
    srl     a
    srl     a
    srl     a
    ld      [hl],a
    pop     hl; restore screen state address



    ; TODO refactor entity loading here ---------------------------------------
    ; TODO --------------------------------------------------------------------
;    push    hl
;    push    bc
;
;    ; find an existing bucket that stores this entity 
;    call    _entity_get_current_room_id
;    call    _entity_find_bucket ; c is the room id, b is the entity id, return a and hl
;    cp      1
;    jp      nz,.not_found
;
;    ; TODO load the stored data
;    
;.not_found:
;    pop     bc
;    pop     hl

    ; check if the entity has stored state 
    ; state is 2 byte per entity [syyy yyyy] [xxxx xxxx]
    ld      a,[de]
    and     %10000000 ; y position is 0-127, first bit indicates whether stored or not
    cp      128
    jp      nz,.entity_load_defaults; not stored, load defaults for position

.entity_load_stored:
    ; store index
    push    hl
    push    de

    ; get entity screen offset for b into hl
    call    _entity_screen_offset_hl
    inc     hl ; skip type
    inc     hl ; skip flags
    inc     hl ; skip direction

    ; y position
    ld      a,[de]
    and     %01111111
    ld      [hl],a
    inc     de
    inc     hl

    ; x position
    ld      a,[de]
    ld      [hl],a

    ; restore index
    pop     de
    pop     hl
    jp      .entity_load_init

    ; TODO --------------------------------------------------------------------
    ; TODO --------------------------------------------------------------------

    ; load default data from map buffer
.entity_load_defaults:

    ; store index
    push    hl
    push    de
    
    ; get entity screen offset for b into hl
    call    _entity_screen_offset_de
    inc     de ; skip type
    inc     de ; skip flags
    inc     de ; skip direction

    ; skip stored type and direction
    inc     hl

    ; load x/y value
    ld      a,[hl]
    and     %11110000 ; y position, just works we can skip the x16 here
    add     16 ; anchor at the bottom
    ld      [de],a
    inc     de

    ; x position
    ld      a,[hl]
    and     %00001111 ; need to multiply by 16 here
    sla     a
    sla     a
    sla     a
    sla     a
    add     8
    ld      [de],a

    ; restore index
    pop     de
    pop     hl

.entity_load_init:

    push    hl

    ld      a,c ; type / dir flags
    and     %00111111 ; mask type bits
    ld      l,a; store entity type
    call    _entity_sprite_offset
    add     a,b ; offset + entity index
    ld      c,a ; store sprite index
    call    sprite_enable

    ; Get palette flag
    push    bc
    ld      a,l; load type
    call    _entity_defintion
    and     %01000000
    srl     a
    srl     a
    ld      b,a
    ld      a,c
    call    sprite_set_palette
    pop     bc

    ; get screen entity offset
    call    _entity_screen_offset_de
    push    bc
    push    de


    ; load entity sprite data into one of the available sprite row slots
    ; in the upper half of the sprite memory
    ld      a,[de] ; load type
    call    _entity_load_tile_row ; -> a = tile offset
    ld      b,a ; load tile offset 
    ld      a,c ; load sprite index
    call    sprite_set_tile_offset


    ; call custom load handler
    ld      a,l
    dec     a; convert into 0 based offset
    ld      hl,DataEntityLoadHandlerTable
    add     a,a  ; multiply entity type by 4
    add     a,a
    add     a,l ; add a to hl
    ld      l,a
    adc     a,h
    sub     l
    ld      h,a

    push    bc
    call    _entity_handler_jump
    pop     bc

    pop     de
    ld      l,c

    ; set sprite position
    inc     de ; skip type
    inc     de ; skip flags
    inc     de ; skip direction

    ld      a,[de] ; load y position
    ld      c,a
    inc     de
    ld      a,[de] ; load x position
    ld      b,a
    ld      a,l ; load sprite index
    call    sprite_set_position

    pop     bc;  restore entity / loop index
    pop     hl

.entity_load_next:
    pop     de; store entity stored state pointer
    inc     de
    inc     de
    inc     hl
    inc     hl

    inc     b
    ld      a,b
    cp      ENTITY_PER_ROOM
    jp      nz,.entity_load_loop
    ret



; Store the entity state into RAM based on the type handler -------------------
entity_store:

    ; calculate offfset into stored state buffer (based on LAST room)
    ld      a,[mapRoomLastY]
    ld      b,a
    ld      a,[mapRoomLastX]
    call    _entity_store_offset; returns the address for the entity in DE

    ld      hl,entityScreenState
    ld      b,0

.loop:
    ld      a,[hl]
    cp      0
    jp      z,.skip; not loaded

    ; find a bucket to store this entity in, either the bucket which already
    ; stores it, or a unused one
;    push    hl
;    push    bc
;    call    _entity_get_last_room_id
;    call    _entity_get_store_bucket
;    cp      1
;    jp      nz,.not_available
;
;.not_available:
;    pop     bc
;    pop     hl

    ; hl = screen state, de = stored state
    inc     hl ; skip type [0]
    inc     hl ; skip flags [1]
    inc     hl ; skip direction [2]

    ; store y position and active flag [3]
    ld      a,[hli]
    or      %10000000
    ld      [de],a
    inc     de

    ; store x position
    ld      a,[hli]
    ld      [de],a
    inc     de

    inc     hl
    inc     hl
    inc     hl
    jp      .next

.skip:
    inc     de
    inc     de
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl

.next:
    inc     b
    ld      a,b
    cp      ENTITY_PER_ROOM
    jp      nz,.loop
    ret


; Reset the entity screen state
entity_reset:
    ld      hl,entityScreenState
    ld      b,0

.loop:
    ld      a,[hl]
    cp      0
    jp      z,.skip; not loaded

    ; disable sprite 
    call    _entity_sprite_offset
    add     a,b; offset + entity index
    call    sprite_disable
    ;call    sprite_unset_mirror ; TODO needed?

    ; unset type
    ld      a,0
    ld      [hl],a

.skip:
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl
    inc     hl

.next:
    inc     b
    ld      a,b
    cp      ENTITY_PER_ROOM
    jp      nz,.loop
    ret


; Update the on screen entites based on the type handler ----------------------
entity_update:
    ld      de,entityScreenState
    ld      b,0

entity_update_loop:

    ; load type / active
    ld      a,[de]
    cp      0
    jp      z,.entity_update_skip; not active skip
    ld      l,a ; store type

    ; get sprite index
    call    _entity_sprite_offset
    add     a,b; offset + entity index
    ld      h,a; store sprite index

    ; store counter, screen state address 
    push    bc
    push    hl
    push    de

    ; invoke custom entity update handler
    ld      a,l
    dec     a; convert into 0 based offset
    ld      hl,DataEntityUpdateHandlerTable
    add     a,a  ; multiply entity type by 4
    add     a,a
    add     a,l ; add a to hl
    ld      l,a
    adc     a,h
    sub     l
    ld      h,a

    push    bc
    call    _entity_handler_jump
    pop     bc

    pop     de
    pop     hl

    inc     de; skip type
    inc     de; skip flags
    inc     de; skip direction

    ld      a,[de] ; x position
    ld      c,a
    inc     de

    ld      a,[de] ; y position
    ld      b,a
    ld      a,h  
    call    sprite_set_position
    inc     de

    pop     bc

    inc     de
    inc     de
    inc     de
    jp      .entity_update_next

.entity_update_skip:
    inc     de
    inc     de
    inc     de
    inc     de
    inc     de
    inc     de
    inc     de
    inc     de

.entity_update_next:
    inc     b
    ld      a,b
    cp      ENTITY_PER_ROOM
    jp      nz,entity_update_loop
    ret


; we use this indirection trick to be able to return from the called code
_entity_handler_jump:
    jp      [hl]


; Entity Sprite Handling ------------------------------------------------------
; -----------------------------------------------------------------------------
_entity_sprite_offset: ; a = sprite type -> a = background offset
    call    _entity_defintion
    and     %10000000
    cp      %10000000
    jp      z,.foreground
    ld      a,ENTITY_BG_SPRITE_INDEX
    ret

.foreground:
    ld      a,ENTITY_FG_SPRITE_INDEX
    ret


_entity_reset_tile_row_mapping:
    ld      hl,entityTileRowMap
    ld      a,255
    ld      [hli],a
    ld      [hli],a
    ld      [hli],a
    ld      [hl],a
    ret


_entity_load_tile_row: ; a = entity type -> a = sprite tile offset for the entity

    push    de
    push    hl
    push    bc

    call    _entity_defintion
    and     %00111111 ; mask tile source row
    ld      c,a ; store tile row into c
    
    ; start search loop for tilerow map
    ld      b,0
    ld      hl,entityTileRowMap

.loop:
    ld      a,[hl]

    ; check if tilerow at this offset is the row required by the entity
    cp      c 
    jp      z,.done

    ; otherwise check if we got a free slow in vram to put the tilerow into
    cp      255
    jp      z,.load

    inc     hl
    inc     b
    cp      4
    jp      nz,.loop

    ; FIXME 
    ; we should never end up here because we got at most 4 different entity
    ; sprite rows
    ld      b,0; failsafe

.load: ; b is the index we we'll be mapping into, c is the sprite row of the entity that needs to be loaded
    
    ; mark tilerow as used
    ld      a,c ; c = sprite row index used for the row at [hl]
    ld      [hl],a

    ; load sprite row for entity
    ld      hl,DataEntityRows
    ld      de,$8400
    ld      a,ENTITY_SPRITE_ROWS * 2
    call    map_load_sprite_row

.done:
    ld      a,b ; load the row into which the sprite data got loaded
    add     a,a ; x4
    add     a,a
    add     a,16 ; skip the first 4 rows in vram

    pop     bc
    pop     hl
    pop     de

    ret



; Helper ----------------------------------------------------------------------
_entity_screen_offset_hl: ; b = entity index
    push    bc

    ld      c,b
    ld      b,0
    ld      hl,entityScreenState
    sla     c ; multiply by 8
    sla     c
    sla     c
    add     hl,bc

    pop     bc
    ret


_entity_screen_offset_de: ; b = entity index
    push    hl
    push    bc

    ld      c,b
    ld      b,0
    ld      hl,entityScreenState
    sla     c ; multiply by 8
    sla     c
    sla     c
    
    add     hl,bc
    ld      d,h
    ld      e,l

    pop     bc
    pop     hl
    ret


_entity_defintion: ; a = sprite type
    push    hl
    ld      hl,DataEntityDefinitions

    dec     a; convert into zero based index

    ; a x 8
    add     a
    add     a
    add     a

    ; hl + a
    add     a,l
    ld      l,a
    adc     a,h
    sub     l
    ld      h,a

    ; load definition
    ld      a,[hl]
    pop     hl
    ret


_entity_store_offset: ; a = room x, b = room y

    inc     a ; convert to 1 based indexing
    ld      h,a

    ld      a,b
    inc     a ; convert to 1 based indexing
    ld      e,a

    ; get room number index into hl
    call    math_mul8b ; hl = h * e 
    dec     hl; convert back to zero based indexing for the room number

    ; multiply by 8 (4 entites per room with 2 bytes each)
    ld      b,h
    ld      c,l
    ld      d,0
    ld      e,8
    call    math_mul16b ; hl = a * de

    ; add storage offset
    ld      de,entityStoredState 
    add     hl,de

    ; move to de
    ld      d,h
    ld      e,l
    ret


; Entity Stored State Buckets -------------------------------------------------
_entity_get_current_room_id: ; c -> room id

    push    hl
    push    de

    ld      a,[mapRoomX]
    inc     a ; convert to 1 based indexing
    ld      h,a

    ld      a,[mapRoomY]
    inc     a ; convert to 1 based indexing
    ld      e,a

    ; get room number index into hl
    call    math_mul8b ; hl = h * e 
    ld      c,l

    pop     hl
    pop     de

    ret


_entity_get_last_room_id: ; c -> room id

    push    hl
    push    de

    ld      a,[mapRoomLastX]
    inc     a ; convert to 1 based indexing
    ld      h,a

    ld      a,[mapRoomLastY]
    inc     a ; convert to 1 based indexing
    ld      e,a

    ; get room number index into hl
    call    math_mul8b ; hl = h * e 
    ld      c,l

    pop     hl
    pop     de

    ret


_entity_get_store_bucket: ; c = room id (1-255), b = entity id (0-3)
    call    _entity_find_bucket; first check for a existing bucket that contains the entity
    cp      1
    ret     z ; found a used bucket for this entity

    ; find a free bucket, if possible
    call    _entity_find_free_bucket
    ret
    

_entity_find_bucket: ; b = room id (1-255), c = entity id (0-3)
    ; return a = 1 if we found a match, in which case hl = data pointer to entity state

    ; [roomid] (1 based indexing)
    ; [ffffff][ii] flags and entity id
    ; [y position]
    ; [x position]
    ld      hl,entityStoreBuckets
    ld      e,0

.loop:
    ld      a,[hl]; get room id
    cp      0
    jp      z,.empty; skip empty buckets

    ; check for room id match
    cp      c
    jp      nz,.skip

    ; check entity id match
    inc     hl
    ld      a,[hl]
    and     %00000011
    dec     hl
    cp      b
    jp      nz,.skip

    ; match found, hl is at the correct offset already
    ld      a,1
    ret

.empty:
.skip:
    inc     hl
    inc     hl
    inc     hl
    inc     hl

    ; break out after going through all rooms
.next:
    inc     e
    ld      a,e
    cp      ENTITY_MAX_STORE_BUCKETS
    jp      z,.not_found
        
    jp      .loop
    
.not_found:
    ld      a,0
    ret


_entity_find_free_bucket:
    ; return a = 1 if we found a free spot, in which case hl = data pointer to entity state

    ; [roomid] (1 based indexing)
    ; [ffffff][ii] flags and entity id
    ; [y position]
    ; [x position]
    ld      hl,entityStoreBuckets
    ld      e,0

.loop:
    ld      a,[hl]; get room id
    cp      0
    jp      nz,.used; skip used buckets

    ; found a free spot, return the pointer
    ld      a,1
    ret

.used:
    inc     hl
    inc     hl
    inc     hl
    inc     hl

    ; break out after going through all rooms
.next:
    inc     e
    ld      a,e
    cp      ENTITY_MAX_STORE_BUCKETS
    jp      z,.not_found
        
    jp      .loop
    
.not_found:
    ld      a,0
    ret

