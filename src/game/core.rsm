; Core Game Code --------------------------------------------------------------
core_loop:

    ; Disable interrupts
    di

    ; init stack pointer
    ld      sp,$ffff

    ; Disable Screen
    call    ScreenOff

    ; Setup DMA transfer
    call    core_setup_dma

    ; Clear RAM, otherwise we will run into problems on real hardware
    ; where it is not going to get initialized
    ld      a,$00           
    ld      hl,$c000
    ld      bc,8192
    call    mem_Set

    ; Clear Bcakground Screen Buffer
    ld      a,$7f
    ld      hl,$9800
    ld      bc,1024
    call    mem_Set

    ; Reset Scroll registers
    ld      a,0
    ld      [rSCX],a
    ld      [rSCY],a

    ; Reset vblank flag
    ld      [coreVBlankDone],a

    ; Reset timer
    ld      [coreTimer125],a
    ld      [coreHalfTickSwitch],a
    ld      [coreHalfTick],a

    ; Run init code and the loop once so we don't have a blank frame on powerup
    call    game_init
    call    game_loop

    ; Enable interrupts
    ei
    ld      a,IEF_VBLANK|IEF_TIMER
    ld      [rIE],a
    ld      a,TACF_START|TACF_4KHZ
    ld      [rTAC],a

    ; Turn on the screen
    call    ScreenOn

    jp      core_loop_main


; Main Loop -------------------------------------------------------------------
core_loop_main:

    halt    ; stop system clock, return from halt when interrupted
    nop     ; If interrupts are disabled halt jumps one instruction!

    ld      a,[coreVBlankDone]
    and     a                   ; V-Blank interrupt ?
    jr      z,core_loop_main    ; No, some other interrupt
    xor     a
    ld      [coreVBlankDone],a  ; Clear V-Blank flag
                                

    ; fetch joypad state
    call    input_read        


    ; run the 1.5 frame loop
    ld      a,[coreHalfTick]
    cp      0
    jp      nz,.no_half_tick

    call    game_loop_half

    ; every other tick we switch the delay between 0 or 1 to 
    ; emulate moving by 1.5 pixels every frame
    ld      a,[coreHalfTickSwitch]
    ld      [coreHalfTick],a

    ; switch between 0 and 1
    ld      a,[coreHalfTickSwitch]
    xor     a
    ld      [coreHalfTickSwitch],a
    jp      .half_ticked

.no_half_tick:
    dec     a
    ld      [coreHalfTick],a

.half_ticked:

    ; run the main loop (every frame)
    call    game_loop

    jr      core_loop_main



; DMA Setup Routine -----------------------------------------------------------
core_setup_dma: ; c = target address, b = byte count, hl = data

    ; copy the DMA transfer code into highram so we can execute it from
    ; the interrupt handler
    ld      c,$80
    ld      b,10
    ld      hl,DMADataOAM
.loop:
    ld      a,[hli]
    ld      [c],a
    inc     c
    dec     b
    jr      nz,.loop
    ret

; transfer 160 bytes in 40 cycles(32 bits per cycle) from C000-C09F to FE00-FE9F
DMADataOAM: 
    DB      $3E, $C0, $E0, $46, $3E
    DB      $28, $3D, $20, $FD, $C9


; Interrupt Handler -----------------------------------------------------------
core_vblank_handler:

    di
    push    af
    push    bc
    push    de
    push    hl

    call    $ff80 ; call the DMA code for transfering data to OAM

    ld      a,1
    ld      [coreVBlankDone],a

    pop     hl
    pop     de
    pop     bc
    pop     af

    reti


; Timer Handler ---------------------------------------------------------------
core_timer_handler:

    di
    push    af
    push    bc
    push    de
    push    hl

    ; 125ms timer
    ld      a,[coreTimer125]
    inc     a
    ld      [coreTimer125],a
    cp      2
    jp      nz,.l125
    call    game_timer_125
    ld      a,0
    ld      [coreTimer125],a
.l125:

    pop     hl
    pop     de
    pop     bc
    pop     af

    reti


; Screen Handler --------------------------------------------------------------
ScreenOff:
    ld      hl,rLCDC
    bit     7,[hl]          ; Is LCD already off?
    ret     z               ; yes, exit

    ld      a,[rIE]
    push    af
    res     0,a
    ld      [rIE],a         ; Disable vblank interrupt if enabled

.screen_off_loop:  
    ld      a,[rLY]         ; Loop until in first part of vblank
    cp      145
    jr      nz,.screen_off_loop
    res     7,[hl]          ; Turn the screen off
    pop     af
    ld      [rIE],a         ; Restore the state of vblank interrupt
    ret

ScreenOn:
    ld      a,LCDCF_ON|LCDCF_BG8800|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ16|LCDCF_OBJON
    ld      [rLCDC],a
    ret


; Data Unpacking --------------------------------------------------------------
core_unpack: ; HL = source, DE = target

    push    hl; store source address

    ; load uncompressed size from packed data
    ld      a,[hl]
    inc     hl
    ld      b,a

    ld      a,[hl]
    ld      c,a

    ; bc = de + size
    ld      h,d
    ld      l,e
    add     hl,bc
    ld      b,h
    ld      c,l

    pop     hl ; restore source address

    ; skip size word again
    inc     hl
    inc     hl

    call    core_unpack_raw

    ret


core_unpack_raw: ; HL = source, DE = target, BC = end (DE + size of data)
.loop:
    ; check if we reached the end of the data uncompressed data (de == bc)
    ld      a,e
    cp      c ; c == e
    jp      nz,.next

    ld      a,d
    cp      b ; b == d
    ret     z

.next:

    ; fetch next instruction byte
    ld      a,[hl]
    inc     hl
    cp      127 ; a > 127
    jp      z,.copy
    jp      c,.copy


    ; repeat X bytes
.repeat:
    
    push    bc ; store end of data

    ; 255 - (count - minRun - 1) (minRun = 2)
    sub     3 ; count - 3
    ld      b,a ; save count
    ld      a,255
    sub     b ; 255 - count, a is now the number of bytes to repeat
    ld      b,a ; set up loop counter

    ; load byte to repeat
    ld      a,[hl]
    inc     hl
    
.repeat_loop:

    ; while count > 0 inc de
    ld      [de],a
    inc     de
    dec     b
    jp      nz,.repeat_loop

    ; next instruction
    pop     bc ; restore end of data
    jp      .loop


    ; copy X bytes
.copy:
    push    bc ; store end of data

    inc     a ; count++
    ld      b,a ; set up loop counter
    
.copy_loop:
    ld      a,[hl] ; load byte to copy
    inc     hl
    ld      [de],a
    inc     de
    dec     b
    jp      nz,.copy_loop

    ; next instruction
    pop     bc ; restore end of data
    jp      .loop

